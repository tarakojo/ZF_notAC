theory ZF_Fragment 
  imports
    "Forcing/Nat_Miscellanea"
    "Forcing/Relative_Univ"
    "Forcing/Synthetic_Definition"
begin 

definition
  infinity_ax :: "(i \<Rightarrow> o) \<Rightarrow> o" where
  "infinity_ax(M) \<equiv>
      (\<exists>I[M]. (\<exists>z[M]. empty(M,z) \<and> z\<in>I) \<and> (\<forall>y[M]. y\<in>I \<longrightarrow> (\<exists>sy[M]. successor(M,y,sy) \<and> sy\<in>I)))"
 
locale M_ZF_Fragment_Trans = 
  fixes M \<Phi>
  assumes 
    upair_ax:         "upair_ax(##M)"
    and Union_ax:         "Union_ax(##M)"
    and power_ax:         "power_ax(##M)"
    and extensionality:   "extensionality(##M)"
    and foundation_ax:    "foundation_ax(##M)"
    and infinity_ax:      "infinity_ax(##M)"
    and separation_ax:    "\<phi>\<in>formula \<Longrightarrow> \<phi> \<in> \<Phi> \<Longrightarrow> env\<in>list(M) \<Longrightarrow> arity(\<phi>) \<le> 1 #+ length(env) \<Longrightarrow>
                    separation(##M,\<lambda>x. sats(M,\<phi>,[x] @ env))" 
    and replacement_ax:   "\<phi>\<in>formula \<Longrightarrow>  \<phi> \<in> \<Phi> \<Longrightarrow> env\<in>list(M) \<Longrightarrow> arity(\<phi>) \<le> 2 #+ length(env) \<Longrightarrow> 
                    strong_replacement(##M,\<lambda>x y. sats(M,\<phi>,[x,y] @ env))" 
    and trans_M:          "Transset(M)"  


    (* Interface *) 
    and interface_inter_fm : "Forall(Implies(Member(0, succ(1)), Member(succ(0), 0))) \<in> \<Phi>"
    and interface_diff_fm : "Neg(Member(0, 1)) \<in> \<Phi>" 
    and interface_cpfm : "Exists(And(Member(0, succ(1)), Exists(And(Member(0, succ(succ(2))), pair_fm(1, 0, succ(succ(0))))))) \<in> \<Phi>"
begin 

lemma separation_consI : 
  "separation(##M,\<lambda>x. sats(M, \<phi>, [x] @ env)) \<Longrightarrow> separation(##M,\<lambda>x. sats(M,\<phi>,Cons(x, env)))" by auto

end
end