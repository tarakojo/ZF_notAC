theory ZF_notAC 
  imports NotAC_Proof 
begin


theorem ZF_notAC_main_theorem :
  fixes M 
  assumes "nat \<approx> M" "M \<Turnstile> ZF" "Transset(M)" 
  shows "\<exists>N. N \<Turnstile> ZF \<and> \<not>(\<forall>A \<in> N. \<exists>R \<in> N. wellordered(##N, A, R))" 
proof - 

  obtain enum where "enum \<in> bij(nat, M)" using assms eqpoll_def by auto
  then interpret M_ctm M enum 
    unfolding M_ctm_def M_ctm_axioms_def
    using M_ZF_iff_M_satT assms 
    by auto
  interpret M_symmetric_system Fn Fn_leq 0 M enum Fn_perms Fn_perms_filter  
    using Fn_M_symmetric_system
    by auto

  obtain G where GH: "M_generic(G)" 
    using generic_filter_existence zero_in_Fn 
    by auto
  then interpret M_symmetric_system_G_generic Fn Fn_leq 0 M enum Fn_perms Fn_perms_filter G
    unfolding M_symmetric_system_G_generic_def
    using M_symmetric_system_axioms G_generic_def forcing_data_axioms G_generic_axioms_def 
    by auto

  define N where "N \<equiv> SymExt(G)" 

  have N_ZF : "N \<Turnstile> ZF" 
    using N_def SymExt_M_ZF M_ZF_iff_M_satT 
    by auto

  have "\<exists>A \<in> N. \<forall>R \<in> N. \<not>wellordered(##N, A, R)"
    apply(rule_tac x="binmap(G)" in bexI)
     apply(rule ballI, rule ccontr)
     apply(rule no_wellorder)
    using GH N_def SymExt_def binmap_eq binmap'_HS
    by auto 
  then show ?thesis using N_ZF by auto
qed

thm forcing_data.generic_filter_existence
thm forcing_data_def



end 