
## 先行研究   
- Isabelle/FOL 
    - https://isabelle.in.tum.de/library/FOL/FOL/outline.pdf
    - Isabelleで一階述語論理を扱うためのフレームワーク
- Isabelle/ZF 
    - https://isabelle.in.tum.de/dist/Isabelle2023/doc/logics-ZF.pdf
    - IsabelleでZF集合論を扱うためのフレームワーク
    - 超限帰納法の形式化など
- Isabelle/ZF-Constructible
    - https://isabelle.in.tum.de/website-Isabelle2009-1/dist/library/ZF/Constructible/README.html
    - Isabelle/ZFの拡張
    - ZF上でエンコードされた論理式, 充足関係の形式化など
    - ZF+ACの相対的無矛盾性が証明されている
- Isabelle/ZF上でによる強制法の形式化
    - https://arxiv.org/pdf/2001.09715.pdf 
    - 強制法の形式化

## 研究

メインの参考文献 : https://karagila.org/files/Forcing-2023.pdf

「The Axiom Of Choice」には、Boolean valued modelを用いた証明が書かれていた。  
前述の文献に沿った証明の方が作業工程が少ない。  
ZFと￢ACをみたすモデルを構成することが主目標。

### 必要な工程

- P-name上の自己同型の形式化
- 強制関係を自己同型が保存することの証明(参考文献のThe Symmetry Lemma)
- symmetric extensionの形式化 (完了)
- それがZFのモデルになっていることの証明
- 特定のsymmetric extensionの構成と、それがACを満たさないことの証明


### 現状
- delta0 separation の証明完了
- separation axiomを証明するために、「symmetric extensionの元である」を表す論理式が必要
  - 現状の定義では難しそう。代替案を考えた
  - その案だとちょっと足りないので修正案を考えた
## 記録

- メインの参考文献 : https://karagila.org/files/Forcing-2023.pdf
  - jechのthe axiom of choiceでは、boolean valued modelを用いているが、isabelleではその形式化がされていない。
  - 前述の参考文献では、preorder Pを用いた強制法を用いているので、Forcingパッケージから流用がしやすい。よってこちらを採用

- P-names全体の集合を定義した。
  - 先行研究の強制法の形式化では、P-names全体の集合を明示的に定義していない。  
    この研究では、「P-names上の関数」を扱う必要があるので、この集合の定義が必要。
  - P-nameのrankと、それに関する帰納法を形式化した。
  - 「P-nameの元である」を表現する論理式を作成した。
  
- Pが半順序という条件を追加している
  - メインの参考文献では、preorder Pにseparativeという制約を追加している。
  - それよりは弱い条件(らしい)
  - 最大元の一意生が欲しかった。Pの自己同型を考える上で議論が楽になる。

- epsilon inductionの形式化
  - <<もっと簡単にできる>>
  - epsilon inductionで定義された関数の値を表現する論理式の作成
  - epsilon inductionで定義された関数の値がMの元であることを証明するための補題
    - その前提条件も説明するべき?

- P上の自己同型の、P-namesへの拡張を定義した。
  - 定義が関数になっていること、domainがP-namesであることは容易に証明できた。
  - rangeがP-namesであることを証明するために、range ⊂ Mを証明する必要があるが、そのためにepsilon inductionで定義された関数の値がMの元であることを示す補題を用いた。
  - 全単射であることの証明をした
    - 方針は、逆写像の存在を言うこと。
    - piの拡張をpi'とかくとき、 pi' o tau' = (pi o tau)'が成立
    - P上の恒等写像idを拡張したid'は、P-names上の恒等写像である
  - P-rankを拡張された自己同型が保存することを証明した
  - 「拡張された自己同型の値である」を表現する論理式を作製した
  
- 強制関係を自己同型が保存することの証明(参考文献のThe Symmetry Lemma)
  - 強制関係の定義が、本や文献と異なる。このギャップを埋めた
    - 具体的には、強制関係の、=と∈の定義に関するforallが、P-name上ではなく、M上を動くようにとられていた
    - 自己同型がP-name上のものなので、SymmetryLemmaを証明するうえで困る
    - この関係はM上で定義する必要があるため、forallをP-name上でとろうとすると、「P-nameである」を表現する論理式が必要であり、これを作る手間を避けたと考えられる
    - valの定義の仕方から、任意のMの元に対し、あるP-name x'があってval(G, x) = val(G, x')
      - 定義は、val(G, x) = { val(G, y). ∃y p. < y, p > ∈ x. p ∈ G }
    - このx'を取り出す関数namifyを作成
      - namify(x) := { < namify(y), p > ∃y p. < y, p > ∈ x. p ∈ P }
    - これでforcingパッケージの強制法の基本定理的なやつも、P-nameを使って書き直せる
  - Symmetry Lemmaの証明 
    - 任意のMの元のリストxに対し、p forces φ(x) <-> πp forces φ(map(π o namify, x))をまず証明し、
    - そこから、任意のP-nameのリストxに対し...を導いた
    - 論理式の構成に関する帰納法
    - base caseはP-rankに関する帰納法
      - 帰納法のステップが複雑。
    - Nandは自明のケースはほぼ自明

- symmetric extensionの形式化
  - HSの形式化は、P-nameの形式化とほぼ同様
  - 「HSの元である」を表す論理式を作成した

- delta0 separationの証明
  - 基本方針は参考文献の方法。
  - rank(u) < rank(x)の部分は、P-rankをM上で表現することが難しかったため、別の条件を用意
    - メタ的な議論で用いている順序数がすべてMの順序数とは限らないため
    - なお、参考文献にあるrankは、P-rankのこと
  - rankの不等式は、yがPn_autoで閉じていることを示すために用いられている。そのような性質を持つ集合に属しているという条件で代用できる
  - delta0sep_Base(x)は、domain(x)を包含し、HSの部分集合で、Pn_autoで閉じている
  - rankの不等式は、条件u ∈ delta0sep_Base(x)で代用
  - xとすべてのパラメータがSymExt(G)の元であるとき、{ u ∈ x. φ(u, params) (in M(G)) }がSymExt(G)の元である
  - φがdelta0で、すべてのパラメータがSymExt(G)の元であるとき φ (in M(G)) <--> φ (in SymExt(G))
  - 前述の２つより、delta0 separationを証明

- separation axiomの証明 
  - 任意の論理式に対して、同値なdelta0論理式が存在することを証明する
  - delta0 separation + almost universalから証明するのが王道っぽい
  - jechでは、delta0 separation + almost universal --> separation の証明には、SymExtがM(G)上のクラスである必要があるが、その証明が難しそう。
  - 別アプローチをとる。
    - 論理式の構造に関する帰納法。∃z. φ(z, y)の形について考えればよい。
    - r(x, p) = least a s.t. ( ∀y ∈ x. (∃z ∈ HS. p ⊩ φ(z, y)) ⇒ zはVset(a)からとれる) 
    - R(x) = { (p, r(x, p)). p ∈ P }
    - R(x) ∈ Mより、R(x) ∈ M(G)
    - よって、R(G) = { R(x, p). p ∈ G } ∈ M(G)
    - sup R(G) ∈ M(G), これはordinalなので、sup R(G) ∈ M
    - よって、Vset(sup R(G)) ∩ HS ∈ M
    - このとき、Vset(sup R(G)) ∩ HSから、witnessとなるzのnameをとることができる。
    - Vset(sup R(G)) ∩ HSを含むような、HSの元をとる。(Xとおく)
    - このとき、 ∃z. φ(z, y) (in SymExt(G)) <--> ∃z ∈ X. φ(z, y) (in SymExt(G)) 