
## 先行研究   
- Isabelle/FOL 
    - https://isabelle.in.tum.de/library/FOL/FOL/outline.pdf
    - Isabelleで一階述語論理を扱うためのフレームワーク
- Isabelle/ZF 
    - https://isabelle.in.tum.de/dist/Isabelle2023/doc/logics-ZF.pdf
    - IsabelleでZF集合論を扱うためのフレームワーク
    - 超限帰納法の形式化など
- Isabelle/ZF-Constructible
    - https://isabelle.in.tum.de/website-Isabelle2009-1/dist/library/ZF/Constructible/README.html
    - Isabelle/ZFの拡張
    - ZF上でエンコードされた論理式, 充足関係の形式化など
    - ZF+ACの相対的無矛盾性が証明されている
- Isabelle/ZF上でによる強制法の形式化
    - https://arxiv.org/pdf/2001.09715.pdf 
    - 強制法の形式化

## 研究

メインの参考文献 : https://karagila.org/files/Forcing-2023.pdf

「The Axiom Of Choice」には、Boolean valued modelを用いた証明が書かれていた。  
前述の文献に沿った証明の方が作業工程が少ない。  
ZFと￢ACをみたすモデルを構成することが主目標。

### 必要な工程

- P-name上の自己同型の形式化
- 強制関係を自己同型が保存することの証明(参考文献のThe Symmetry Lemma)
- symmetric extensionの形式化 (完了)
- それがZFのモデルになっていることの証明
- 特定のsymmetric extensionの構成と、それがACを満たさないことの証明


### 現状
- separation axiomを証明するために、「symmetric extensionの元である」を表す論理式が必要
  - M上の特定の条件を満たすクラス上に定義された帰納的関数を表す論理式を作成した
  - M上のepsilon inductionにより定義される関数を表す論理式を作成した
  - 「P-nameである」「HSの元である」を表す論理式を作成した
  

## 記録

- 特定の条件を満たすM上のクラスに定義される再帰関数を表す論理式を作成した
- M上のepsilon inductionにより定義される関数を表す論理式を作成した


#### P-name上の自己同型の形式化
- P-names全体の集合を定義した。
  - 先行研究の強制法の形式化では、P-names全体の集合を明示的に定義していない。  
    この研究では、「P-names上の関数」を扱う必要があるので、この集合の定義が必要。
  - P-nameのrankと、それに関する帰納法を形式化した。
  - 「P-nameの元である」を表現する論理式を作成した。
  
- Pにseparativeという条件を追加している
  - メインの参考文献では、preorder Pにseparativeという制約を追加している。
  - この制約を追加しても、一般性は失われない(らしい)。
  - separativeなpreorderは半順序なので、最大元があれば、それは一意に定まる。  
    Pの自己同型を考える上でも、議論が楽になる。

- P上の自己同型の、P-namesへの拡張を定義した。
  - 定義が関数になっていること、domainがP-namesであることは容易に証明できた。
  - rangeがP-namesであることの証明が大変だった。
    - 関数の値が、Mの元であることを示す必要がある。
    - そのために、M内のZF公理で関数の値が構成できることを示す必要がある。
    - この関数は再帰的定義なので、この関数を(部分的に)エミュレートするM内の関数が要る。
    - M内のwell-founded recursiveな関数の存在を言う補題は既に存在したが、これを適用するのが大変だった。
      - ほしい再帰的関数がみたす等式を、ZF上でエンコードされた論理式で表現する必要があった。
      - この補題には、関数がパラメータをとれないという欠点がある。
      - P上の自己同型をパラメータとした再帰的関数が欲しかったので、  
        再帰のもととなるwell-founded relationにパラメータを仕込んで回避した。
        (R上の再帰 --> R x {pi}上の再帰にした)
      - 一般化して、パラメータ付きの再帰的関数の存在を言う補題を作れそう。
  - 全単射であることの証明をした
    - 方針は、逆写像の存在を言うこと。
    - piの拡張をpi'とかくとき、 pi' o tau' = (pi o tau)'が成立
    - P上の恒等写像idを拡張したid'は、P-names上の恒等写像である
  - P-rankを拡張された自己同型が保存することを証明した
  - 「拡張された自己同型の値である」を表現する論理式を作製した
  
- 強制関係を自己同型が保存することの証明(参考文献のThe Symmetry Lemma)
  - 強制関係の定義が、本や文献と異なる。このギャップを埋めた
    - 具体的には、強制関係の、=と∈の定義に関するforallが、P-name上ではなく、M上を動くようにとられていた
    - 自己同型がP-name上のものなので、SymmetryLemmaを証明するうえで困る
    - この関係はM上で定義する必要があるため、forallをP-name上でとろうとすると、「P-nameである」を表現する論理式が必要であり、これを作る手間を避けたと考えられる
    - valの定義の仕方から、任意のMの元に対し、あるP-name x'があってval(G, x) = val(G, x')
      - 定義は、val(G, x) = { val(G, y). ∃y p. < y, p > ∈ x. p ∈ G }
    - このx'を取り出す関数namifyを作成
      - namify(x) := { < namify(y), p > ∃y p. < y, p > ∈ x. p ∈ P }
    - これでforcingパッケージの強制法の基本定理的なやつも、P-nameを使って書き直せる
  - Symmetry Lemmaの証明 
    - 任意のMの元のリストxに対し、p forces φ(x) <-> πp forces φ(map(π o namify, x))をまず証明し、
    - そこから、任意のP-nameのリストxに対し...を導いた
    - 論理式の構成に関する帰納法
    - base caseはP-rankに関する帰納法
      - 帰納法のステップが複雑。
    - Nandは自明のケースはほぼ自明

- symmetric extensionの形式化
  - HSの形式化は、P-nameの形式化とほぼ同様
  - 「HSの元である」を表す論理式を作成した


- と、それがZFのモデルになっていることの証明
- 特定のsymmetric extensionの構成と、それがACを満たさないことの証明
