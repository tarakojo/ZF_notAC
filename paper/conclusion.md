# Isabelle/ZF and prior work

## Isabelle/ZFについて
Isabelleは、Paulsonにより開発された定理証明支援系で、
数学的証明の形式化や、プログラムの検証などに利用されています。
1986年のリリースから、現在に至るまで、多くの研究者により開発が続けられています。

Isabelleの実績の例として、seL4マイクロカーネルの形式検証があります。
これは、100万行以上のIsabelleコードを含む巨大なプロジェクトです。
また最近では、The ALEXANDRIA Projectにおいて、
様々な高度な数学的結果の形式証明が行われました。

Isabelleは、論理体系Pureに関する定理証明を行うためのツールです。
Pureの上にFirst order logic, higher order logicなど、
他の論理体系が構築されており、それらの論理体系に対しても定理証明を行うことができます。

Isabelle/ZFは、Isabelle上で構築されたFirst order logicの上に、
さらにZermelo-Fraenkel set theoryを構築したものです。
ZFの公理たちが公理として追加されており、選択公理をさらに追加することもできます。
順序数・基数・関数・順序集合など、ZFに関する多くの定義・定理が形式化され、
ライブラリとして提供されています。

フロントエンドの、Isabelle/jEditを用いると、
定義された集合論に関する糖衣構文を用いて、
集合論の定理を直感的に記述することができるのも利点です。

## 
ここでは、本研究で利用する、先行研究においてなされた重要な形式化について説明します。

### basics of ZF set theory
Isabelle/ZFでは、ZF集合論の基本的な概念が形式化されています。
例えば、集合、部分集合、空集合、べき集合、順序数、基数、関数、順序集合などが定義されています。
...
また、以下のように、separationやreplacementを直感的に記述することもできます。
...
順序数演算や基数演算も形式化されており、例えば、以下のように記述できます。
...

### datatype and primrec 
paulsonは、ZF集合論の中で、再帰的データ型を定義するためのdatatypeと、
その上の関数を定義するためのprimrecを導入しました。
これにより、ZF集合論上でlistなどを定義することができるようになります。
例えば、listは、datatypeを用いて以下のように定義されます。
...
また、リスト上の関数mapは、primrecを用いて以下のように定義されます。
... 

### class and relativization 
Isabelle/ZF上で、クラスCは一変数述語として表現されます。
C(x)は、xがCに属することを表します。
例えば、順序数全体のクラスOrdが定義されており、αが順序数であることは、Ord(α)と表されます。
また、∀x[C].P(x)という表記で、任意のx∈CでP(x)が成り立つことを表し、
∃x[C].P(x)という表記で、あるx∈CでP(x)が成り立つことを表します。

### internalized formula and satisfaction
guntherらは、強制法の形式化をするにあたり、Isabelle/ZFの中でさらにコード化された、集合論の言語の論理式を定義しました。
これは、Paulsonによって導入された、ZF集合論の中で再帰的データ型を定義するdatatypeによって以下のように定義されています。
...

論理式は、集合論のde Brujinインデックスを用いて表現されます。
例えば、...

また、これらの論理式に関する充足関係も、Paulsonによるprimrecで定義されています。
この関係は、集合、論理式、論理式のパラメータを引数にとります。
...

### locales and internalized ZF axioms
Isabelleには、ロケールという機能があります。
これは、特定のコンテキスト内でのみ有効な定義や定理を行うための機能です。
例えば、以下ではGを群とする、と仮定をおいて、群について論じていくような場合に便利です。
paulsonやguntherは、ZF集合論の内部モデルを扱うためのロケールを定義しています。
ここでは、guntherによる、locale "M_ctm"について説明します。M_ctmは、以下のように定義されています。
...
M_ctmを利用するための記法のひとつとして、以下のものがあります。
...
このとき、context M_ctm ... endで囲まれた部分では、M_ctmの仮定、つまり、
集合Mとenumがあって、...などの公理を満たすという仮定が利用できます。
ロケール中で定義した定義や定理は、指定したパラメーターがロケールのインスタンスを成すとき、つまり
ロケールの仮定を全て満たすとき、ロケールの外側でも利用できます。
例えば、集合A, enumAがあって、A, enumAがM_ctmのインスタンスを成すことを証明すれば、
M_ctmの中で証明された補題...が利用できます。

M_ctmの条件の中で、separation_axとreplacement_axは、
分離公理と置換公理を表現するためのもので、以下のように定義されています。
...
定義から分かるように、これらの公理を適用するためには、
望む性質をinternalized formulaで表現する必要があります。

### forcing 
guntherらは、ZF集合論の中で強制法を形式化しました。
その中の強制関係の形式化は、p ⊩ φ env という形で定義されています。
ここで、pは強制法の条件、φは論理式、envは論理式のパラメータです。
section2で紹介した以下の重要な定理が、実際に成り立っていることがわかります。
...
ただし、この形式化においては、φのパラメータとしてP-namesだけではないMの元が許されています。
これでもうまくいくように定義が調整されています。

