\documentclass{report}
\usepackage{graphicx} 
\usepackage{luacode}  
\usepackage{ascmac}
\usepackage{comment}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{xcolor}
\usepackage{authblk}
\usepackage{url}

\usepackage{mdframed}  

\usepackage{fontspec}
%\usepackage{luatexja-fontspec}
% コード用フォントはとりあえずこれで
% 等幅じゃないけど見やすい
\setmonofont{TeXGyreDejaVuMath-Regular}[Scale=0.75]

% fontspecは先にしないとエラーが出る?
\usepackage{newtxtext,newtxmath}


% 参考文献
\usepackage[backend=biber,style=authoryear]{biblatex}
\addbibresource{main.bib}


% URL
\usepackage{hyperref}
\hypersetup{luatex, pdfencoding=auto}

% コード表示
\usepackage[outputdir=out]{minted} 

\usepackage{cleveref}

% isabelleコードの枠
\newenvironment{isaframe}
  {\begin{mdframed}[topline=false, rightline=false, bottomline=false]}
  {\end{mdframed}}
\newenvironment{isaframe2}[2]
  {\begin{mdframed}[topline=false, rightline=false, bottomline=false, frametitle={{\tiny \href{#1}{#2}}}]}
  {\end{mdframed}}
  

% 定理
\newtheorem{thm}{Theorem}[section]
\newtheorem{lem}[thm]{Lemma}
\newtheorem{dfn}[thm]{Definition}
\newtheorem{cor}[thm]{Corollary}
\newtheorem{prop}[thm]{Proposition}

% 参照
\crefname{chapter}{Chapter}{Chapters}
\crefname{section}{Section}{Sections}
\crefname{dfn}{Definition}{Definitions}
\crefname{lem}{Lemma}{Lemmas}
\crefname{thm}{Theorem}{Theorems}
\crefname{cor}{Corollary}{Corollaries}
\crefname{prop}{Proposition}{Propositions} 

 
\title{Formal Proof of the Relative Consistency of ZF$+\neg$AC with Isabelle/ZF}
\author{Daiki Funane}
\affil{Graduate School of Information Sciences, Tohoku University \\
(Draft of Master's Thesis)}

\begin{document}

\maketitle

\chapter*{Abstract}
This paper presents a formalization of the relative consistency of the negation of the Axiom of Choice ($\neg$AC) 
with respect to Zermelo-Fraenkel set theory (ZF) using the proof assistant Isabelle/ZF. 
We use the countable transitive model (c.t.m.) approach, assuming the existence of a c.t.m.\ of ZF, 
and apply forcing to construct a symmetric extension called the basic Cohen model, 
which serves as a model of ZF + $\neg$AC. This work builds on previous formalizations, 
such as forcing (Gunther et al. 2020), and provides the first formalization of the relative consistency of $\neg$AC with ZF.
The proof is based on (Karagila 2023) and (Jech 2008), which align well with the c.t.m.\ approach,
although the proof that the symmetric extension satisfies the axioms of ZF required modification to fit this formalization.
The formalization process gave insights into the challenges of formalizing set theory and the potential for future improvements.

\chapter*{Acknowledgements}
本研究を進めるにあたり、大変多くのご指導を賜りました住井 英二郎教授ならびに織田 幸弘氏に、深く感謝いたします。
研究という活動は初めてでしたが、お二人のご指導のおかげで、何とか本論文を執筆することができました。

また、本論文の副審査委員を務めていただきました、横山 啓太教授、中野 圭介教授に感謝申し上げます。
横山教授には、研究の過程においても数学的な視点からご助言をいただきました。

さらに、研究について建設的な議論をしていただいた、薄葉 季路教授、湯山 孝雄氏、谷口 雅弥氏、
そして、ゼミ発表の場でご意見をいただいた松田 一孝准教授、西田 雄気助教、Oleg Kiselyov氏に感謝申し上げます。

最後に、家族をはじめとする学生生活を支えていただきました皆様に、深く感謝いたします。

\clearpage
\tableofcontents
\clearpage




\chapter{Introduction}

\paragraph{Proof Assistants}
 
Proof assistants are software tools designed to formally verify mathematical proofs, programs, and more. 
These systems are widely used in various fields, including mathematics \parencite{four_color,kepler}, cryptography \parencite{EasyCrypt_AWS,EasyCrypt_zero_knowledge}, 
hardware verification \parencite{Coq_hardware_verification,Coq_hardware_verification_2},
and program verification \parencite{survey_proof_assistants_program_verification}. 
Operating on the basis of formal logic, they enable users to interactively construct proofs, which are then checked by the system.
Well-known examples of proof assistants include Isabelle \parencite{isabelle_toppage}, Coq \parencite{coq_toppage}, Lean \parencite{lean_toppage} Agda \parencite{agda_toppage}, and HOL Light \parencite{hol_light_toppage},
each offering unique features and strengths \parencite{survey_theorem_provers}.

One of the key advantages of proof assistants is their ability to guarantee the correctness of proofs. 
In manually constructed proofs, errors can easily occur due to human mistakes, 
and even when the proof is correct, it can be difficult to verify its correctness.
Proof assistants provide a solution to these problems by rigorously checking each logical step of given proof,
ensuring its correctness.

In particular, these systems are effective in verifying proofs involving intricate case analysis.
For example, the Four Color Theorem \parencite{four_color} and Kepler's Conjecture \parencite{kepler} are well-known cases of theorems formally proven using proof assistants. 
These large-scale proofs were difficult for humans to verify manually, but their correctness was assured through formal verification.
Similarly, in systems where safety is critical, formal verification of programs can significantly enhance their reliability. 
Notable examples of formally verified systems include the CompCert C compiler \parencite{compcert} and the seL4 microkernel \parencite{seL4}.

Proof assistants are not limited to applications requiring complex case analysis;
they are also widely used in efforts to formalize various mathematical theorems. 
Fundamental mathematical results, such as those in group and ring theory or calculus, 
have been formalized by many proof assistants, and the scope of such formalizations continues to expand.
For example, mathlib \parencite{mathlib} is a library actively developed in Lean, including formalizations of various mathematical concepts and theorems.

The results presented in this paper involve the formalization of theorems in axiomatic set theory using Isabelle. 
This also serves as an example of a formal proof of an argument using forcing.

\paragraph{Axiomatic Set Theory}

Set theory plays a crucial role as the foundation of modern mathematics. 
From natural numbers and functions to more advanced and complex concepts, 
mathematical ideas and theorems can basically be expressed within the framework of set theory. 
As a result, set theory functions as a common language in modern mathematics.

In the 19th century, set theory was devised by Cantor, bringing significant progress to mathematics. 
However, during its development, issues such as Russell's paradox emerged.
Axiomatic set theory was developed to address these issues and to investigate which operations on sets are permissible. 
In axiomatic set theory, allowable operations are strictly defined by axioms, and the theory is constructed based on these axioms.

Over time, various axiom systems have been proposed, 
and the relationships and independence among these systems have been studied. 
Among the axiom systems in axiomatic set theory, 
the Zermelo-Fraenkel system (ZF) and the Neumann-Bernays-Gödel system (NBG) are well-known. 
This paper primarily focuses on the ZF and ZFC axiom systems.

The Zermelo-Fraenkel (ZF) axiom system is an extension of the axiom system proposed by Zermelo, 
further developed by Fraenkel, Skolem, von Neumann, and others. 
When the Axiom of Choice is included, the system is referred to as ZFC and is widely used. 
These axiom systems are defined within the framework of first-order logic 
and include infinitely many axioms specified by axiom schemas.
It is well known that most mathematical concepts can be expressed within ZFC, 
and its properties have been widely studied.

Among these, the independence of the Axiom of Choice (AC) in ZF 
and the independence of the Continuum Hypothesis (CH) in ZFC are significant early results. 
These were proven by Cohen using a technique known as forcing.

While this paper provides a brief explanation of axiomatic set theory, 
a detailed exposition can be found in standard textbooks such as \parencite{kunen2011,jech_set_theory}.

\paragraph{Relative Consistency and Independence}

One of the interesting and important aspects of axiomatic set theory is that 
multiple "levels" of set theory appear within arguments.
For example, by formalizing first-order logical formulas and formal proof systems such as sequent calculus within ZFC set theory, 
it is possible to build ZFC set theory internally within ZFC itself.

We also use ZF or ZFC externally and consider other set theories within them. 
In this paper, we often refer to the external system as the meta-level set theory 
and the one constructed within it as the object-level set theory.

Basically, when we say "$\varphi$ is provable in the axiom system $T$", $T$ refers to the object-level set theory, not the meta-level. 
In other words, it means that within the formal proof system constructed on the meta-level set theory, the axiom system 
$T$ and the formula $\varphi$, also constructed within the same system, can be proven.

A proposition $\varphi$ is said to be independent of an axiom system $T$ if neither $\varphi$ nor $\neg \varphi$ is provable in $T$.
This is equivalent to saying that both the system $T+\varphi$ and $T+\neg \varphi$ are consistent,
where $T+\varphi$ denotes the system obtained by adding $\varphi$ to $T$.
Furthermore, in first-order logic, an axiom system is considered consistent if it has a model.
Therefore, to prove that $\varphi$ is independent of $T$, it is sufficient to show that both $T+\varphi$ and $T+\neg \varphi$ have models.

However, when considering $T$ as systems like ZF or ZFC, it is impossible, within the current context, 
to demonstrate their consistency without any assumptions, due to Gödel's incompleteness theorem. 
Instead, the consistency of the system of interest is proven by assuming the consistency of another axiom system. 
This property is referred to as relative consistency.

From the above, to be precise, the independence of AC in ZF is proven by assuming the consistency of ZF 
and showing that both ZF + AC and ZF + $\neg$AC have models. 
(However, in the current setting, the consistency of ZF and the consistency of ZFC are equivalent, so it is also valid to assume the consistency of ZFC.)
Similarly, the independence of CH in ZFC is proven by assuming the consistency of ZFC 
and showing that both ZFC + CH and ZFC + $\neg$CH have models.
Forcing is a powerful technique for carrying out such proofs.

\paragraph{Forcing}

Forcing is a technique first introduced by Cohen \parencite{cohen} to prove the independence of AC in ZF 
and the independence of CH in ZFC. 
It is a powerful method for exploring models of set theory, 
and it has been further refined by other researchers over time, 
leading to many significant results being established through its use. 
Forcing continues to play a crucial role in contemporary research in axiomatic set theory.

As will be explained in more detail in \cref{chap:preliminaries}, 
forcing is a technique for extending models of set theory.
Given a model $M$ of set theory and a poset $P$ within $M$,
applying the forcing method produces the smallest extension $M[G]$ (called a generic extension) of $M$ 
that includes a set $G$ known as a generic filter on $P$.
By carefully choosing $P$, it is possible to control certain properties that hold in $M[G]$.
Furthermore, what holds or does not hold in $M[G]$ can be identified using the forcing relation.

For example, independence of CH is proven by assuming the consistency of ZFC to obtain a model of ZFC, 
and then extending it using forcing to construct a model of ZFC in which CH holds 
and another model in which $\neg$CH hold.
In the case of AC, a submodel of a generic extension is constructed to obtain a model of ZF where AC does not hold.

\paragraph{Previous Research on the Formalization of Axiomatic Set Theory}

As with other areas of mathematics, the formalization of axiomatic set theory using proof assistants has also been advancing.

Paulson et al. formalized an extensive part of ZF set theory,
including cardinal arithmetic \parencite{paulson_cardinal_AC}, relativization \parencite{paulson_AC_consistency}, the reflection theorem \parencite{paulson_reflection}, 
features for handling inductive definitions \parencite{paulson_datatype_impl}, and the relative consistency of AC with ZF \parencite{paulson_AC_consistency}
The proof of the relative consistency was achieved by constructing Gödel's constructible universe.

Building on these results, Gunther et al. formalized forcing and a proof of the independence of CH \parencite{gunther_forcing,gunther_independence} in Isabelle/ZF.
In these formalizations, they used the countable transitive model (c.t.m.) approach, 
which we also adopt in this paper.

In Lean, Han and van Doorn also formalized forcing and the independence of CH \parencite{flypitch} in Lean 3.
using the Boolean-valued model approach, which is another approach to forcing.
Additionally, in Lean 4, Holmes and Wilshaw formalized the complex parts of the consistency proof of Quine's New Foundations \parencite{NF_consistency}, ensuring the correctness of the proof.

Although these results have been formalized, 
the relative consistency of $\neg$AC with ZF has not yet been formalized. 

\paragraph{Our Contribution and Approach}

In this paper, we formalize the proof of the relative consistency of $\neg$AC with ZF using Isabelle/ZF.

This work contributes to the formalization of axiomatic set theory 
and serves as a new example of the formalization using forcing, which is a crucial tool in set theory.
It also highlights parts of the process that require significant effort 
and provides insights into how future formalizations could be made more efficient.

The primary reason we chose Isabelle/ZF for this formalization is that Isabelle/ZF is a mature proof assistant for ZF set theory,
in particular, the formalization by \parencite{gunther_forcing} is a major advantage for this study.
Although there is also a formalization of forcing in Lean 3 by Han and van Doorn \parencite{flypitch}, development for Lean 3 has already ended.

We adopted the c.t.m.\  approach for our proof to use Gunther et al.'s formalization, as in their independence proof of CH.
Specifically, we show th relative consistency of $\neg$AC with ZF 
by assuming the existence of a c.t.m.\  of ZF and constructing a model of ZF+$\neg$AC by forcing.
This model is known as the basic Cohen model, which is a symmetric extension of assumed c.t.m.\ 
Constructing the basic Cohen model by forcing is 
one of traditional methods for proving the relative consistency of $\neg$AC with ZF.

Our proof is based on Karagila's lecture note \parencite{karagila} and Jech's book \parencite{jech_AC},
as these resources align well with the c.t.m.\  approach.
However, some parts of the proof required modification to fit the formalization in Isabelle/ZF.

The c.t.m.\ approach is a well-established method for relative consistency proofs in axiomatic set theory.
This approach will be explained in detail in \cref{subsection:ctm}.
The discussion regarding the validity of the c.t.m.\ approach, 
which is often omitted or only briefly mentioned in paper-based proofs, has not yet been formalized, and its formalization is desirable.
Further details about this will be provided in \cref{chap:conclusion}.


\paragraph{Synopsis}
The remainder of this thesis is outlined as follows.
In Chapter 2, we first explain set-theoretic concepts in Section 2.1.
Section 2.2 outlines an informal proof (i.e., a proof on paper) of the relative consistency of $\neg$AC with ZF, which is formalized in Chapter 3.
In Section 2.3, we provide an overview of Isabelle/ZF and highlight key results from prior work that are relevant to this study.
Chapter 3 presents the formalization of the relative consistency proof of ZF+$\neg$AC, building on the contents of Chapter 2.
Finally, Chapter 4 concludes the thesis.

\paragraph{Repository}
Our source code is available at: \url{https://github.com/tarakojo/ZF_notAC}




\chapter{Preliminaries}\label{chap:preliminaries}



\section{Set-Theoretic Preliminaries}
In this section, we introduce the concepts of set theory used in the formalization of this study.
We discuss in ZFC, within which we explore ZF itself. 
Basically, our definition and theorems combine \parencite{kunen2011}, \parencite{karagila}, and \parencite{jech_AC}
adapted to the formalized form in Isabelle/ZF.


\subsection{ZF Set Theory and the Axiom of Choice}
We introduce the axioms of ZF set theory and the Axiom of Choice (AC).
We use first-order logic with the language of set theory, which consists of only two relation symbols $\in$ and $=$. 
Formulas involving other mathmatical operators that may appear are considered abbreviations for formulas in this language.
Parentheses in formulas are omitted where no confusion arises.

\begin{dfn}
  The axioms of ZF are the following statements:
  \begin{itemize}
    \item Extensionality: $\forall x \forall y (\forall z (z \in x \leftrightarrow z \in y) \rightarrow x = y)$
    \item Pairing: $\forall x \forall y \exists z \forall w (w \in z \leftrightarrow w = x \lor w = y)$
    \item Union: $\forall x \exists y \forall z (z \in y \leftrightarrow \exists w (z \in w \land w \in x))$
    \item Power set: $\forall x \exists y \forall z (z \in y \leftrightarrow z \subseteq x)$
    \item Infinity: $\exists x (\emptyset \in x \land \forall y (y \in x \rightarrow y \cup \{y\} \in x))$
    \item Regularity: $\forall x(x \neq \emptyset \rightarrow \exists y (y \in x \land y \cap x = \emptyset))$
    \item Infinity: $\forall x (x \neq \emptyset \rightarrow \exists y (y \in x \land \forall z (z \in x \rightarrow z \notin y)))$
    \item Separation: $\forall p \forall x \exists y \forall z (z \in y \leftrightarrow z \in x \land \phi(z, p))$
    \item Replacement: $\forall p (\forall x \forall y \forall z (\phi(x, y, p) \land \phi(x, z, p) \rightarrow y = z) \rightarrow \\ \forall X \exists Y \forall y (y \in Y \leftrightarrow \exists x (x \in X \land \phi(x, y, p))))$
  \end{itemize}
\end{dfn}
Where separation and replacement are axiom schemas, representing infinitely many axioms for each formula $\phi$ with an appropriate arity.
\begin{dfn} 
  \emph{The Axiom of Choice} is the following statement: \\
  $\forall x \exists f (\mathrm{"} f \text{ is a function on } x \mathrm{"} \land \forall y (y \in x \rightarrow f(y) \in y))$
\end{dfn}
Where the phrase "f is a function on x" is also considered an abbreviation in the language of set theory.
Additionally, we introduce the well-ordering theorem, as we treat AC in this form.

\begin{dfn}
  We say that a linear ordering $<$ on a set $P$ is a \emph{well-ordering} if, every non-empty subset of $P$, it has a least element.
\end{dfn}

\begin{lem}
  The Axiom of Choice is equivalent to the well-ordering theorem, which states that every set can be well-ordered.
\end{lem}


\subsection{Forcing}
Forcing is a tequnique used in proving relative consistency and independence.
We introduce basic concepts of forcing in the context of the c.t.m.\  approach.
In this approach, the relative consistency proof is achieved by using forcing to construct a extended model by adding new sets to an assumed c.t.m.\ 
Let $M$ be a c.t.m.\  of ZF and $(\mathbb{P}, \leq_{\mathbb{P}})$ be a notion of forcing, which is a pre-ordered set in $M$ with a maximum element $1_{\mathbb{P}}$.

\begin{dfn}
  We define $M^{\mathbb{P}}$, the set of \emph{$\mathbb{P}$-names}, by transfinite recursion on ordinals:
  \begin{enumerate}
    \item $M^{\mathbb{P}}_0 = \emptyset$
    \item $M^{\mathbb{P}}_{\alpha + 1} = \mathcal{P}^M(M^{\mathbb{P}}_{\alpha} \times \mathbb{P})$
    \item $M^{\mathbb{P}}_{\alpha} = \bigcup_{\beta < \alpha} M^{\mathbb{P}}_{\beta}$ for a limit ordinal $\alpha$
    \item $M^{\mathbb{P}} = \bigcup_{\alpha \in \mathrm{Ord}} M^{\mathbb{P}}_{\alpha}$
  \end{enumerate}
\end{dfn}
Where $\mathcal{P}^M$ denotes the power set operation in $M$. 
We often write a $\mathbb{P}$-name with a dot, e.g., $\dot{x}$.
The least $\alpha$ such that $\dot{x} \in M^{\mathbb{P}}_{\alpha + 1}$ is called the \emph{$\mathbb{P}$-rank} of $\dot{x}$.
This allows us to define functions and relations by recursion on $\mathbb{P}$-names.

\begin{dfn}  
  \,
  \begin{enumerate}
    \item We say that $D \subseteq \mathbb{P}$ is \emph{dense} if, for every $p \in \mathbb{P}$, there exists $q \in D$ such that $q \leq_{\mathbb{P}} p$.
    \item We say that $G \subseteq \mathbb{P}$ is a \emph{filter} if following conditions hold:
      \begin{itemize}
        \item If $p \in G$, $q \in \mathbb{P}$, and $p \leq_{\mathbb{P}} q$, then $q \in G$
        \item If $p, q \in G$, there exists $r \in G$ such that $r \leq_{\mathbb{P}} p$ and $r \leq_{\mathbb{P}} q$
      \end{itemize}
    \item We say that $G \subseteq$ is \emph{generic filter} on $\mathbb{P}$ if $G$ is a filter and for any dense $D \subseteq \mathbb{P}$, $D \cap G \neq \emptyset$.
  \end{enumerate}
\end{dfn}

The following lemma shows that a generic filter actually exists.
\begin{lem} 
  For any $p \in \mathbb{P}$, there exists a generic filter $G$ on $\mathbb{P}$ such that $p \in G$.
\end{lem}

\begin{dfn} 
  Let $G$ be a generic filter on $\mathbb{P}$ and $\dot{x} \in M^{\mathbb{P}}$. We define the \emph{interpretation} of $\dot{x}$ denoted by $\dot{x}^G$ recursively with respect to the $\mathbb{P}$-rank of $\dot{x}$:
  $$\dot{x}^G = \{\dot{y}^G \mid \exists p \in G (\langle \dot{y}, p \rangle \in \dot{x})\}$$ 
\end{dfn}

We call a $\mathbb{P}$-name whose interpretation is a set $x$ a name of $x$ and denote it by $\dot{x}$.
Note that a single set may have multiple names.

\begin{dfn} 
  Let $G$ be a generic filter on $\mathbb{P}$. We define a \emph{generic extension} $M[G]$ as $\{x^G \mid \dot{x} \in M^{\mathbb{P}}\}$.
\end{dfn}

\begin{thm} 
  Let $G$ be a generic filter on $\mathbb{P}$. Then, $M[G]$ is the smallest c.t.m.\  of ZF extending $M$ and containing $G$.
\end{thm}

By choosing $\mathbb{P}$ appropriately, we can construct $M[G]$ with various properties.
What holds or does not hold in $M[G]$ can be identified using the forcing relation.
The forcing relation is defined recursively on formulas in a forcing language.
The forcing language is an extension of the language of set theory by adding the elements of $M^{\mathbb{P}}$ as constants.
\begin{dfn} \label{dfn:forcing_relation}
  We define the \emph{forcing relation} $\Vdash$ for formulas in the forcing language and $p \in \mathbb{P}$ inductively
  \footnote{
    Specifically, the forcing relation is first defined for atomic formulas $\dot{x} = \dot{y}$ and $\dot{x} \in \dot{y}$ by mutual recursion,
    inductively on the $\mathbb{P}$-rank of $\dot{x}$ and $\dot{y}$.
    Then, the definition is extended to all formulas in the forcing language by induction on the complexity of formulas.
  }
  as follows:
  \begin{enumerate}
    \item $p \Vdash \dot{x} = \dot{y} \Leftrightarrow \forall \dot{z} \in \mathrm{dom}(\dot{x}) \cup \mathrm{dom}(\dot{y})\,
\forall q \leq_{\mathbb{P}} p \, (q \Vdash \dot{z} \in \dot{x} \leftrightarrow q \Vdash \dot{z} \in \dot{y})$
    \item $p \Vdash \dot{x} \in \dot{y} \Leftrightarrow \forall q \leq_{\mathbb{P}} p\, \exists r \leq_{\mathbb{P}} q \, 
    \exists s \in \mathbb{P} \, \exists \dot{z} \in M^{\mathbb{P}} \, (\langle \dot{z}, s \rangle \in \dot{y} \land r \leq_{\mathbb{P}} s \land r \Vdash \dot{x} = \dot{z} )$
    \item $p \Vdash \phi \land \psi \Leftrightarrow p \Vdash \phi \land p \Vdash \psi$
    \item $p \Vdash \neg \phi \Leftrightarrow \forall q \leq_{\mathbb{P}} p \, \neg (q \Vdash \phi)$
    \item $p \Vdash \exists x \phi(x) \Leftrightarrow \forall q \leq_{\mathbb{P}} p \, \exists r \leq_{\mathbb{P}} q \, \exists \dot{x} \in M^{\mathbb{P}} \, (r \Vdash \phi(\dot{x}))$
  \end{enumerate}
\end{dfn}
We say that $p$ \emph{forces} $\phi$ if $p \Vdash \phi$.

\begin{thm}[The Truth Lemma] \label{thm:truth_lemma}
  Let $G$ be a generic filter on $\mathbb{P}$, $\varphi$ be a formula, and $\dot{x} \in M^{\mathbb{P}}$, then 
  $$M[G] \vDash \varphi(\dot{x}^G) \Leftrightarrow \exists p \in G \, (p \Vdash \varphi(\dot{x}))$$
\end{thm}

\begin{cor}\label{cor:truth_lemma_cor}
  Let $p \in \mathbb{P}$, $\varphi$ be a formula and $\dot{x} \in M^{\mathbb{P}}$, then
  $$p \Vdash \varphi(\dot{x}) \Leftrightarrow \text{for any generic filter } G \text{ containing } p, M[G] \vDash \varphi(\dot{x}^G)$$
\end{cor}


\subsection{Symmetric Extensions}\label{subsection:symmetrc_extensions}
Symmetric extensions are substructures of generic extensions of a given c.t.m.\  of ZF 
and are formed by interpreting only the hereditarily symmetric names.
Let $M$ be a c.t.m.\  of ZF, $(\mathbb{P}, \leq_{\mathbb{P}})$ be a pre-ordered set in $M$ with the maximum element $1_{\mathbb{P}}$.

\begin{dfn} \label{dfn:automorphism}
  We say that $\pi : \mathbb{P} \rightarrow \mathbb{P}$ is an \emph{automorphism} if for all $p, q \in \mathbb{P}$, $p \leq_{\mathbb{P}} q \Leftrightarrow \pi p \leq_{\mathbb{P}} \pi q$.
  $\pi$ induces an bijection on $\mathbb{P}$-names defined recursively as follows:
  $$ \pi \dot{x} = \{ \langle \pi \dot{y}, \pi p \rangle \mid \langle \dot{y}, p \rangle \in \dot{x} \} $$
\end{dfn}

\begin{dfn} 
  Let $\mathcal{G}$ be a group of automorphisms of $\mathbb{P}$. We say that $\mathcal{F}$ is a \emph{normal filter} on $\mathcal{G}$ if the following conditions hold:
  \begin{enumerate}
    \item $\mathcal{F}$ is non-empty family of subgroups of $\mathcal{G}$.
    \item $\mathcal{F}$ is closed under finite intersections and supergroups.
    \item For every $H \in \mathcal{F}$ and $\pi \in \mathcal{G}$, $\pi H \pi^{-1} \in \mathcal{F}$.
  \end{enumerate}
\end{dfn}

We fix a group of automorphisms $\mathcal{G}$ of $\mathbb{P}$ and a normal filter $\mathcal{F}$ on $\mathcal{G}$.
\begin{dfn} 
  For every $\mathbb{P}$-name $\dot{x}$, let $\mathrm{sym}(\dot{x}) = \{ \pi \in \mathcal{G} \mid \pi \dot{x} = \dot{x} \}$.
  We say that $\mathbb{P}$-name $\dot{x}$ is \emph{symmetric} if $\mathrm{sym}(\dot{x}) \in \mathcal{F}$.
\end{dfn}

\begin{dfn} \label{dfn:hereditarily_symmetric}
  We define the set of all hereditarily symmetric names $\mathrm{HS}$ recursively as follows:
  \begin{enumerate}
    \item $0 \in \mathrm{HS}$
    \item if $\mathrm{dom}(\dot{x}) \subseteq \mathrm{HS}$ and $\dot{x}$ is symmetric, then $\dot{x} \in \mathrm{HS}$
  \end{enumerate}
\end{dfn}

\begin{dfn} 
  Let $G$ be a generic filter on $\mathbb{P}$. The set $\mathrm{HS}^{G} = \{ \dot{x}^G \mid \dot{x} \in \mathrm{HS} \}$ is called a \emph{symmetric extension} of $M$.
\end{dfn}

\begin{thm}
  Let $G$ be a generic filter on $\mathbb{P}$. Then, the symmetric extension $\mathrm{HS}^{G}$ is a c.t.m.\  of ZF and a substructure of $M[G]$.
\end{thm}

\begin{dfn}
  The relativized forcing relation $\Vdash_{\mathrm{HS}}$ is defined as the forcing relation $\Vdash$ with $M^{\mathbb{P}}$ in its definition replaced by $\mathrm{HS}$.
\end{dfn}

The relation $\Vdash_{\mathrm{HS}}$ acts as the forcing relation for symmetric extensions.

\begin{thm}\label{thm:symmetry_truth_lemma}
  Let $G$ be a generic filter on $\mathbb{P}$, $\mathcal{N}$ be a symmetric extension generated by $G$, $\varphi$ be a formula, and $\dot{x} \in \mathrm{HS}$, then
  $$\mathcal{N} \vDash \varphi(\dot{x}) \Leftrightarrow \exists p \in G \, (p \Vdash_{\mathrm{HS}} \varphi(\dot{x}))$$
\end{thm}

\begin{cor}\label{cor:symmetry_truth_lemma_cor}
  Let $p \in \mathbb{P}$, $\varphi$ be a formula, and $\dot{x} \in \mathrm{HS}$, then
  $$p \Vdash_{\mathrm{HS}} \varphi(\dot{x}) \Leftrightarrow \text{for any generic filter } G \text{ containing } p, \mathcal{N} \vDash \varphi(\dot{x}^G)$$
  Where $\mathcal{N}$ is the symmetric extension generated by $G$.
\end{cor}

The following lemmas also holds for the forcing relation $\Vdash$, but we only state them for $\Vdash_{\mathrm{HS}}$.

\begin{lem}\label{lem:strengthening}
  Let $p, q \in \mathbb{P}$, $\varphi$ be a formula. If $q \leq_{\mathbb{P}} p$ and $p \Vdash_{\mathrm{HS}} \varphi$, then $q \Vdash_{\mathrm{HS}} \varphi$.
\end{lem}

\begin{lem}[The Symmetry Lemma]\label{lem:symmetry_lemma}
  Let $\pi$ be an automorphism of $\mathbb{P}$, $\dot{x}_0, \ldots, \dot{x}_n \in \mathrm{HS}$, and $\varphi$ be a formula, then
  $$p \Vdash_{\mathrm{HS}} \varphi(\dot{x}_0, \ldots, \dot{x}_n) \Leftrightarrow \pi p \Vdash_{\mathrm{HS}} \varphi(\pi \dot{x}_0, \ldots, \pi \dot{x}_n)$$
\end{lem}


\subsection{The c.t.m.\  Approach}\label{subsection:ctm}
This section explains the c.t.m.\ approach.
This approach is a well-established method for proving relative consistency in axiomatic set theory,
as it is covered in \parencite{kunen2011}.

Specifically, the approach assumes the existence of a countable transitive model (c.t.m.) 
of an axiom system $S$ of set theory and show the existence of a c.t.m.\ for another axiom system $T$, 
thereby proving the relative consistency of $T$ with respect to $S$.
This approach is useful because it allows discussions to proceed without worrying about the complicated details that can arise.

It should be noted that discussions are needed to confirm the validity of this approach.
By definition, the relative consistency of $T$ with respect to $S$ means that if $S$ is consistent, then $T$ is also consistent.
Assuming that $S$ is consistent, by the completeness theorem, we can prove that $S$ has a model.
However, the existence of a c.t.m.\  of $S$ cannot be necessarily derived from the consistency of $S$.

Nonetheless, the c.t.m.\  approach is valid for proving the relative consistency.
The following presents a discussion on the validity of the approach.
In accordance with the content of this paper, we proceed with the discussion by letting $S$ be ZF and $T$ be ZF + $\neg$AC.
However, the discussion below is also applicable to other cases.

First, we introduce some concepts,
following Jech \parencite{jech_set_theory}, chapter 6 and 12.

\begin{prop}[Reflection Principle]
Let $\varphi(x_1, \ldots, x_n)$ be a formula. There is a transitive set $M$ such that 
$$\varphi^M(x_1, \ldots, x_n) \leftrightarrow \varphi(x_1, \ldots, x_n)$$
for every $x_1, \ldots, x_n \in M$.
\end{prop}
Where $\varphi^M$ denotes the relativization of $\varphi$ to $M$.
In other words, $\varphi^M$ is the formula obtained 
by replacing every quantifier $\forall x$ by $\forall x \in M$ and $\exists x$ by $\exists x \in M$.
Note that this is a theorem schema for every formula $\varphi$.

\begin{dfn}
  Let $E$ be a binary relation on a set $P$.
  \begin{itemize}
    \item 
  We say thet $E$ is \emph{well-founded} if every non-empty subset of $P$ has an $E$-minimal element.
  \item
  We say that $E$ is extensional if:
  $$\mathrm{ext}_E(x) \ne \mathrm{ext}_E(y)$$
  whenever $x$ and $y$ are distinct elements of $P$, 
  where 
  $$\mathrm{ext}_E(x) = \{ z \in P \mid z\ E\ x \}$$ 
\end{itemize}
\end{dfn}

\begin{thm}[Mostowski's Collapsing Theorem]
  If $E$ is a well-founded and extensional relation on a set $P$, 
  then there is a transitive set $M$ and an isomorphism $\pi$ between $(P, E)$ and $(M, \in)$.
\end{thm}

\begin{thm}[L\"owenheim-Skolem Theorem]\label{thm:lowenheim_skolem}
  Every infinite model for a countable language has a countable elementary submodel.
\end{thm}

Using these, we can prove the following proposition:
\begin{prop}\label{prop:ctm_finite}
  Let $\Gamma$ be a finite fragment of ZF axioms, including the Axiom of Extensionality,
  then there exists a c.t.m.\ of $\Gamma$.
\end{prop}
\begin{proof}
  Let $\Gamma = \{ \varphi_1, \ldots, \varphi_n \}$ and $\psi = \varphi_1 \land \ldots \land \varphi_n$.
  By reflection principle, there exists a set $M$ such that $\psi^M \leftrightarrow \psi$.
  Then, $\mathcal{M} = (M, \in \mid_{M \times M})$ satisfies $\psi$. 
  In other words, $\mathcal{M}$ is a model of $\Gamma$.
  By \cref{thm:lowenheim_skolem}, there exists a countable elementary submodel $\mathcal{N} = (N, \in \mid_{N \times N})$ of $\mathcal{M}$.  
  $\mathcal{N}$ satisfies the Axiom of Extensionality since $\Gamma$ includes it.
  Additionary, by the Axiom of Regularity, every non-empty subset of $N$ has an $\in$-minimal element.
  Therefore, $\in \mid_{N \times N}$ is well-founded and extensional.
  By Mostowski's Collapsing Theorem, there exists a transitive set $N_0$ and an isomorphism between $(N, \in \mid_{N \times N})$ and $(N_0, \in)$.
  Thus, $N_0$ is a c.t.m.\ of $\Gamma$.
\end{proof}

Here, we use this to explain the validity of the c.t.m.\ approach.
First, let us assume the existence of a c.t.m.\  of ZF and 
suppose that we can prove the existence of a c.t.m.\ of ZF+$\neg$AC by forcing.
It should also be possible to prove the following by modifying the proof.

\begin{prop}\label{prop:ctm_finite2}
  Let $\Gamma$ be a finite fragment of ZF, 
  there exists a finite fragment $\Delta$ of ZF+$\neg$AC such that
  if a c.t.m.\  of $\Gamma$ exists, then a c.t.m.\  of $\Delta$ also exists.
\end{prop}

This is because, in the original proof, 
the axiom of ZF used to formalize forcing are finite, 
and the proof that a c.t.m.\ of ZF+$\neg$AC satisfies each axiom of ZF+$\neg$AC should 
only require a finite number of axioms of ZF. 

By combining \cref{prop:ctm_finite,prop:ctm_finite2}, 
we can prove the following\footnote{
  Since the Reflection Principle is a theorem schema,
  this is also a theorem schema for every $\Delta$.
}.
\begin{prop} \label{prop:ctm_finite3}
  Let $\Delta$ be a finite fragment of ZF+$\neg$AC,
  there exists a c.t.m.\  of $\Delta$. 
  In other words, $\Delta$ is consistent.
\end{prop}

Here, let us prove the relative consistency of ZF+$\neg$AC by contradiction.
Assume that ZF+$\neg$AC is inconsistent.  
Then, since ZF+$\neg$AC proves $\bot$ (a contradiction),  
there exists a finite fragment $\Delta$ of ZF+$\neg$AC such that $\Delta$ proves $\bot$.  
In other words, $\Delta$ is inconsistent.  
However, by \cref{prop:ctm_finite3}, $\Delta$ is consistent, which leads to a contradiction.
Therefore, ZF+$\neg$AC is consistent.


\section{Outline for the Informal Proof}\label{sec:outline}
We outline an informal proof of the relative consistency of $\neg$AC with ZF which we will formalize in the next chapter.
In this proof, the relative consistency is proved by assuming the existence of a c.t.m.\  of ZF and constructing a model of ZF+$\neg$AC by forcing. 
This model is a symmetric extension called the basic Cohen model.

Let $M$ be a c.t.m.\  of ZF, $\mathbb{P}$ be the set of all finite partial functions from $\omega \times \omega$ to $2 = \{0, 1\}$
that are elements of $M$, and $\leq_{\mathbb{P}}$ be $\supseteq$.
Note that the maximum element $1_{\mathbb{P}}$ is the empty set. 
Let $\pi$ be a bijection on $\omega$. $\pi$ induces an automorphism on $\mathbb{P}$ defined as follows:
$$\mathrm{dom}(\pi p) = \{ (\pi n, m) \mid (n, m) \in \mathrm{dom}(p) \}$$
$$(\pi p)(\pi n, m) = p(n, m)$$
This automorphism further induces an automorphism on $\mathbb{P}$-names. 
Let $\mathcal{G}$ be the group of all such automorphisms.
For every finite $e \subseteq \omega$, let 
$$\mathrm{fix}(e) = \{ \pi \in \mathcal{G} \mid \forall n \in e (\pi n = n) \}$$
Let $\mathcal{F}$ be the set of all subgroups $H$ of $\mathcal{G}$ such that there exists a finite $e \subseteq \omega$ with $\mathrm{fix}(e) \subseteq H$.
Note that $\mathcal{F}$ is a normal filter on $\mathcal{G}$. Let $\mathcal{N} = \mathrm{HS}^{G}$.
Since $\mathcal{N}$ is a symmetric extension of $M$, it is a c.t.m.\  of ZF. 

\begin{thm}
  $\mathcal{N}$ does not satisfy the well-ordering theorem.
\end{thm}

\begin{proof}
We outline the proof of this theorem as follows. 
For every $n \in \omega$, let $a_n$ be the following real number (a subset of $\omega$):
$$a_n = \{ m \in \omega \mid \exists p \in G (p(n, m) = 1) \}$$
Since $a_n$ are pairwise distinct, $A = \{ a_n \mid n \in \omega \}$ is an infinity set.
$A$ and every $a_n$ are elements of $\mathcal{N}$.
$A$ serves as a counterexample to the well-ordering theorem in $\mathcal{N}$.
Suppose for contradiction that $A$ is well-ordered in $\mathcal{N}$, there exists a injection $f$ from $\omega$ to $A$ in $\mathcal{N}$.
Let $\varphi(g,x,y)$ be a formula that represents the relation $g(x) = y$. 
For every $n \in \omega$ with $a_n \in \mathrm{ran}(f)$, there exists $i \in \omega$ such that $N \vDash \varphi(f, i, a_n)$.
Thus there exists $p \in G$ and hereditarily symmetric names $\dot{f}, \dot{i}$ and $\dot{a_n}$ for each of $f, i, a_n$ such that 
$$p \Vdash_{\mathrm{HS}} \varphi(\dot{f}, \dot{i}, \dot{a_n})$$
By choosing $n$ and the names appropriately, we can find a bijection $\pi$ on $\omega$ such that the following conditions are additionally satisfied:
\begin{enumerate}
  \item $\pi \dot{f} = \dot{f}$
  \item $\pi \dot{i} = \dot{i}$
  \item $\pi n \ne n$
  \item There exists a hereditarily symmetric name $\dot{a_{\pi n}}$ of $a_{\pi n}$ such that $\pi \dot{a_n} = \dot{a_{\pi n}}$
  \item There exists $q \in G$ such that $q \leq_{\mathbb{P}} p$ and $q \leq_{\mathbb{P}} \pi p$
\end{enumerate}
Note that some occurence of $\pi$ in above conditions refer to the induced automorphism on $\mathbb{P}$ or $\mathbb{P}$-names..
By \cref{lem:symmetry_lemma}
$$\pi p \Vdash_{\mathrm{HS}} \varphi(\pi \dot{f}, \pi \dot{i}, \pi \dot{a_n})$$
Thus 
$$\pi p \Vdash_{\mathrm{HS}} \varphi(\dot{f}, \dot{i}, \dot{a_{\pi n}})$$
Therefore, by \cref{lem:strengthening}
$$q \Vdash_{\mathrm{HS}} \varphi(\dot{f}, \dot{i}, \dot{a_n}) \mathrm{ and } q \Vdash_{\mathrm{HS}} \varphi(\dot{f}, \dot{i}, \dot{a_{\pi n}})$$
This means that $\mathcal{N} \vDash \varphi(f, i, a_n)$ and $\mathcal{N} \vDash \varphi(f, i, a_{\pi n})$, which implies that $f(i) = a_n$ and $f(i) = a_{\pi n}$.
Since $a_n$ and $a_{\pi n}$ are distinct, this is a contradiction. 
\end{proof}
 


\section{Isabelle/ZF and Formalization in Prior Work}
In this section, we introduce Isabelle/ZF, a proof assistant for ZF set theory, 
and important results from prior work used in the formalization of this study.


\subsection{Isabelle and Isabelle/ZF}
Isabelle is a proof assistant developed \parencite{paulson_1986}, used for formalizing mathematical proofs and verifying programs. 
Since its release in 1986, it has continued to be developed by many researchers.

One notable example of Isabelle's achievements is the formal verification of the seL4 microkernel \parencite{seL4}.
This was a massive project involving over a million lines of Isabelle code. 
More recently, in The ALEXANDRIA Project \parencite{alexiandria}, various advanced mathematical results have been formalized in Isabelle.

Isabelle is a tool for proving theorems of the loical system called Pure. 
On top of Pure, other logical systems such as first-order logic (Isabelle/FOL) and Higher-Order Logic (Isabelle/HOL) are built,
and Isabelle allows proving theorems in these logical systems.

Isabelle/ZF is an extension of Isabelle/FOL.
It extends Isabelle/FOL by adding the axioms of ZF, allowing theorems of ZF set theory to be proved.
Additionally, the Axiom of Choice can be included, enabling theorems of ZFC to be proved in Isabelle/ZF.
Many definitions and theorems regarding ZF, such as ordinals, cardinals, functions, and ordered sets, 
have been formalized and provided as a library.


\subsection{Important Results from Prior Work in Isabelle/ZF}


\subsubsection{Recursive Data Types and Functions}
\parencite{paulson_datatype_impl} introduced \texttt{"datatype"} to recursive data types within ZF set theory, 
and "primrec" to define functions on top of these data types. 
This made it possible to define data structures such as lists within ZF set theory.
For example, the set of all lists of elements from a set $A$ is defined in a library of Isabelle/ZF as follows:
\begin{isaframe} 
\begin{minted}[breaklines]{isabelle}
consts
    list       :: "i⇒i"

datatype
    "list(A)" = Nil | Cons ("a ∈ A", "l ∈ list(A)")
\end{minted}
\end{isaframe}
Additionally, the function "length" on lists is defined using "primrec" as follows.
\begin{isaframe}
\begin{minted}[breaklines]{isabelle}
consts
    length :: "i⇒i"

primrec
    "length([]) = 0"
    "length(Cons(a,l)) = succ(length(l))"
\end{minted}
\end{isaframe}


\subsubsection{Class and Relativization}
In Isabelle/ZF, a class $C$ is represented as a unary predicate $C(x)$.
The statement $x \in C$ is represented as $C(x)$.
For example, the class of all ordinals $\mathrm{Ord}$ is defined in a library of Isabelle/ZF as \texttt{"Ord"},
and the fact that \texttt{"α"} is an ordinal is represented as \texttt{"Ord(α)"}.

Additionally, the notation \texttt{"∀x[C]. P(x)"} represents that \texttt{"P(x)"} holds for all \texttt{"x"} in the class \texttt{"C"},
and \texttt{"∃x[C]. P(x)"} represents that there exists an \texttt{"x"} in the class \texttt{"C"} such that \texttt{"P(x)"} holds.
Using this notation, we can obtain the relativized statement to a class \texttt{"C"} 
by replacing all \texttt{"∀x"} and \texttt{"∃x"} in a original statement with \texttt{"∀x[C]"} and \texttt{"∃x[C]"}, respectively.


\subsubsection{Internalized Formula and Satisfaction Relation}
Paluson defined formulas encoded as sets in ZF set theory in their work \parencite{paulson_AC_consistency},
using \texttt{"datatype"} as follows:
\begin{isaframe}
\begin{minted}[breaklines]{isabelle}
consts   formula :: i
datatype
    "formula" = Member ("x ∈ nat", "y ∈ nat")
                      | Equal  ("x ∈ nat", "y ∈ nat")
                      | Nand ("p ∈ formula", "q ∈ formula")
                      | Forall ("p ∈ formula")
\end{minted}
\end{isaframe}
Note that \texttt{"nat"} is the set of natural numbers.
The unique logical connective in this definition is NAND and 
other logical connectives such as AND, OR, and NOT on formulas are defined in terms of NAND.
Formulas are represented using the de Brujin index, in other words, 
a occurence of a natural number $n$ in a formula represents the $(n - m)$-th free variable when this $n$ occurs under $m$ quantifiers.

Additionally, the satisfaction relation \texttt{"sats(A, φ, env)"} is defined.
This relation represents that \texttt{"A"} satisfies the formula \texttt{"φ"} 
under the environment \texttt{"env"}, where \texttt{"env"} is a list of elements of \texttt{"A"}.
Note that the arity of \texttt{"φ"} must be less than or equal to the length of \texttt{"env"}.

For example, \texttt{"sats(A, Member(0, 1), [a, b])"} is equivalent to \texttt{"a ∈ b"} when \texttt{"[a, b] ∈ list(A)"}, 
and \texttt{"sats(A, Forall(Member(0, 1)), [c])"} is equivalent to \texttt{"∀x ∈ A. c ∈ x"} when \texttt{"[c] ∈ list(A)"}.


\subsubsection{Locales and Internalized ZF Axioms}
Isabelle provides a feature called locales, 
which allows us to work more easily in a specific context by fixing constants and introducing assumptions.
For example, when formalizing group theory, rather than adding the assumption "$G$ is a group" to every theorem,
we can simply declare a locale with the constant $G$ and the assumption "$G$ is a group".
 
Paulson and Gunther et al. declared locales to handle internal models of ZF set theory in their work \parencite{paulson_AC_consistency, gunther_forcing}, respectively.
For example, the locale \texttt{"M\_ctm"} by Gunther et al. fixes \texttt{"M"} and \texttt{"enum"},
and introduces assumptions that \texttt{"M"} holds the axioms of ZF set theory, 
\texttt{"M"} is a transitive set, and \texttt{"enum"} is a enumeration of \texttt{"M"}.
Therefore, we can work in the context of a c.t.m.\  of ZF by working within this locale.


\subsubsection{Forcing}
Gunther et al. formalized forcing method in ZF set theory \parencite{gunther_forcing}.
Their formalization follows Kunen's book \parencite{kunen2011}, which uses the c.t.m.\  approach.

They defined the notion of forcing as the locale \texttt{"forcing\_notion"} 
with the constants \texttt{"P"}, \texttt{"leq"}, and \texttt{"one"}.
\begin{isaframe}
\begin{minted}[breaklines]{isabelle}
locale forcing_notion =
    fixes P leq one
    assumes one_in_P:     "one ∈ P"
      and leq_preord:       "preorder_on(P,leq)"
      and one_max:          "∀p∈P. ⟨p,one⟩∈leq"
\end{minted}
\end{isaframe}

They also declared the locale \texttt{"forcing\_data"} 
by combining the locale \texttt{"forcing\_notion"} with the locale \texttt{"M\_ctm"} and assume some additional properties. 
\begin{isaframe}
\begin{minted}[breaklines]{isabelle}
locale forcing_data = forcing_notion + M_ctm +
    assumes P_in_M:         "P ∈ M"
      and leq_in_M:         "leq ∈ M"
\end{minted}
\end{isaframe}

Within this locale, The predicate \texttt{"p ⊩ φ env"} is defined.
This represents that \texttt{"p"} forces the formula \texttt{"φ"} under the environment \texttt{"env"}.
Additionally, the following
\footnote{
In \cref{dfn:forcing_relation},
we explained that the forcing relation is defined for the formulas in the forcing language.
According to that definition, \texttt{"env"} should be a list of elements of $M^{\mathbb{P}}$;
however, in the following lemmas, \texttt{"env"} is a list of elements of $M$.
In fact, the definition of the forcing relation by Gunther et al. differs from \cref{dfn:forcing_relation}.
They defined the forcing relation not for the formulas in the forcing language 
but for the formulas in the extended language of set theory by adding all elements of $M$ as constants.
Additionally, only NAND is used as the logical connective, and only $\forall$ is used as the quantifier of the formulas.
} is their formalization of \cref{thm:truth_lemma} and \cref{cor:truth_lemma_cor}.
\begin{isaframe}
\begin{minted}[breaklines]{isabelle}
lemma truth_lemma:
    assumes 
        "φ∈formula" "M_generic(G)"
    shows 
        "⋀env. env∈list(M) ⟹ arity(φ)≤length(env) ⟹ 
          (∃p∈G. p ⊩ φ env)   ⟷   M[G], map(val(G),env) ⊨ φ"

lemma definition_of_forcing:
    assumes
        "p∈P" "φ∈formula" "env∈list(M)" "arity(φ)≤length(env)"
    shows
        "(p ⊩ φ env) ⟷
        (∀G. M_generic(G) ∧ p∈G  ⟶  M[G], map(val(G),env) ⊨ φ)"
\end{minted}
\end{isaframe}
Where \texttt{"M\_generic(G)"} represents that \texttt{"G"} is a generic filter on \texttt{"P"} in \texttt{"M"},
\texttt{"val(G)"} is the interpretation by \texttt{"G"},
and \texttt{"map"} is the map function on lists.




\chapter{Formalization of the Proof} 
In this chapter, we present the formalization of the relative consistency proof of $\neg$AC with ZF in Isabelle/ZF.
We follow the outline presented in \cref{sec:outline}.
We choose \emph{ZF-Constructible} by \parencite{paulson_AC_consistency} as Isabelle theory 
\footnote{Note that this does not mean assuming $V=L$.}
, which includes the ZF axioms along with useful definitions and lemmas built on top of them.
We also reuse the formalization of forcing by \parencite{gunther_forcing}.



\section{Symmetric Extensions}


\subsection{Defining Symmetric Extensions}
First, we define symmetric extensions in Isabelle/ZF,
formalizing automorphisms, normal filters, and hereditarily symmetric names.


\subsubsection{$\mathbb{P}$-names}
We begin our work within the locale \texttt{"forcing\_data"} by \parencite{gunther_forcing}, 
in which a c.t.m.\  \texttt{"M"} and a notion of forcing \texttt{"P"} are fixed.
The relation $\leq_{\mathbb{P}}$ is denoted by \texttt{"leq"} and 
a maximum element $1_{\mathbb{P}}$ is denoted by \texttt{"one"}.

Gunther et al. did not provide an excplicit formalization of the set of $\mathbb{P}$-names $M^{\mathbb{P}}$ in their work.
In this study, since we need to consider a subset of $M^{\mathbb{P}}$, we define $M^{\mathbb{P}}$ explicitly.
We define $M^{\mathbb{P}}_{\alpha}$ as \texttt{"P\_set(α)"} and $M^{\mathbb{P}}$ as \texttt{"P\_names"} as follows:

\begin{isaframe2}
    {https://github.com/tarakojo/ZF_notAC/blob/177e94cf29db6fb3b0be1e4b2f84d5cd7508a7f4/code/P_Names.thy\#L10}
    {P\_Names.thy}
\begin{minted}[breaklines]{isabelle}
definition HP_set_succ :: "[i, i] ⇒ i" where 
    "HP_set_succ(a, X) ≡ Pow(X × P) ∩ M" 

definition P_set :: "i ⇒ i" where 
    "P_set(a) ≡ transrec2(a, 0, HP_set_succ)" 

definition P_names :: "i" where "P_names ≡ { x ∈ M . ∃ a. Ord(a) ∧ x ∈ P_set(a) }" 
\end{minted}
\end{isaframe2}

Where \texttt{"transrec2(α, x, H)"} is the function defined in \emph{ZF} library
that returns \texttt{x} when \texttt{α} is 0;
when \texttt{α} is a successor ordinal, it returns \texttt{H(β, transrec2(β, x, H))} where \texttt{β} is the predecessor of \texttt{α};
and when \texttt{α} is a limit ordinal, it returns $\bigcup$\texttt{β∈α. transrec2(β, x, H)}.
Note that in Isabelle/ZF, the notation \texttt{"\{ x ∈ A. P(x) \}"} denotes
the set of elements in \texttt{A} that satisfy the predicate \texttt{P}.


\subsubsection{Automorphisms}
To simplify the formalization, we declare and work within the locale \texttt{"forcing\_data\_partial"}, 
where $\mathbb{P}$ is assumed to be a partially ordered set. 
Note that \texttt{"one"} is the unique maximum element of $\mathbb{P}$ in this locale.

\begin{isaframe2}
  {https://github.com/tarakojo/ZF_notAC/blob/177e94cf29db6fb3b0be1e4b2f84d5cd7508a7f4/code/HS_Definition.thy\#L7}
  {forcing\_data\_partial.thy}
\begin{minted}[breaklines]{isabelle}
locale forcing_data_partial = forcing_data + 
    assumes leq_relation_on_P : "leq ∈ Pow(P × P)" 
    and leq_partial_order : "partial_order_on(P, leq)" 
\end{minted}
\end{isaframe2}

We define the set of automorphisms on $\mathbb{P}$, denoted by \texttt{"P\_auto"}, as follows:
\begin{isaframe2}
  {https://github.com/tarakojo/ZF_notAC/blob/177e94cf29db6fb3b0be1e4b2f84d5cd7508a7f4/code/Automorphism_Definition.thy\#L25}
  {Automorphism\_Definition.thy}
\begin{minted}[breaklines]{isabelle}
definition is_P_auto :: "i ⇒ o" where
    "is_P_auto(π) ≡ π ∈ M ∧ π ∈ bij(P, P) ∧ (∀ p ∈ P. ∀q ∈ P. p ≼ q ⟷ π`p ≼ π`q)"  

definition P_auto where "P_auto ≡ { π ∈ P → P. is_P_auto(π) }" 
\end{minted}
\end{isaframe2}

Where \texttt{"bij(A, B)"} is the set of bijections from \texttt{A} to \texttt{B}
and \texttt{"f`x"} denotes the function application of \texttt{f} to \texttt{x}.
We denote the induced automorphism on $\mathbb{P}$-names by \texttt{π} as \texttt{"Pn\_auto(π)"}.
Our definition of \texttt{"Pn\_auto"} satisfies the equality given in \cref{dfn:automorphism}.
\begin{isaframe2}
  {https://github.com/tarakojo/ZF_notAC/blob/177e94cf29db6fb3b0be1e4b2f84d5cd7508a7f4/code/Automorphism_Definition.thy\#L155}
  {Automorphism\_Definition.thy}
\begin{minted}[breaklines]{isabelle}
lemma Pn_auto : 
    "x ∈ P_names ⟹ Pn_auto(π)`x = { <Pn_auto(π)`y, π`p> . <y, p> ∈ x}"  
\end{minted}
\end{isaframe2}



\subsubsection{Groups of Automorphisms and Normal Filters}
First, we define the set of all subgroups of a group of automorphisms \texttt{G} that are in \texttt{"M"}.
\begin{isaframe2}
  {https://github.com/tarakojo/ZF_notAC/blob/177e94cf29db6fb3b0be1e4b2f84d5cd7508a7f4/code/HS_Definition.thy\#L10}
  {HS\_Definition.thy}
\begin{minted}[breaklines]{isabelle}
  definition is_P_auto_group where 
      "is_P_auto_group(G) ≡ 
        G ⊆ { π ∈ P → P. is_P_auto(π) } 
      ∧ (∀π ∈ G. ∀τ ∈ G. π O τ ∈ G) 
      ∧ (∀π ∈ G. converse(π) ∈ G)"   
  
  definition P_auto_subgroups where 
      "P_auto_subgroups(G) ≡ { H ∈ Pow(G) ∩ M. is_P_auto_group(H) }" 
\end{minted}
\end{isaframe2}
Where \texttt{"π O τ"} denotes the composition of \texttt{π} and \texttt{τ}.
Then, we declare a locale \texttt{"M\_symmetric\_system"} that fixes a group of automorphisms \texttt{"𝒢"} and a normal filter \texttt{"ℱ"} on \texttt{"𝒢"}.
\begin{isaframe2}
  {https://github.com/tarakojo/ZF_notAC/blob/177e94cf29db6fb3b0be1e4b2f84d5cd7508a7f4/code/SymExt_Definition.thy\#L7}
  {SymExt\_Definition.thy}
\begin{minted}[breaklines]{isabelle}
locale M_symmetric_system = forcing_data_partial + 
    fixes 𝒢 ℱ 
    assumes 𝒢_in_M : "𝒢 ∈ M"  
    and 𝒢_P_auto_group : "is_P_auto_group(𝒢)"   
    and ℱ_in_M : "ℱ ∈ M"
    and ℱ_subset : "ℱ ⊆ P_auto_subgroups(𝒢)" 
    and ℱ_nonempty : "ℱ ≠ 0" 
    and ℱ_closed_under_intersection : "∀A ∈ ℱ. ∀B ∈ ℱ. A ∩ B ∈ ℱ" 
    and ℱ_closed_under_supergroup : 
        "∀A ∈ ℱ. ∀B ∈ P_auto_subgroups(𝒢). A ⊆ B ⟶ B ∈ ℱ" 
    and ℱ_normal : "∀H ∈ ℱ. ∀π ∈ 𝒢. { π O τ O converse(π). τ ∈ H } ∈ ℱ" 
\end{minted}
\end{isaframe2}

\subsubsection{Hereditarily Symmetric Names}
We continue our work within the locale \texttt{"M\_symmetric\_system"}.
We define the set of hereditarily symmetric names \texttt{"HS"} in the same way as \texttt{"P\_names"}.
This approach makes it easier to use induction based on the $\mathbb{P}$-rank of names.

\begin{isaframe2}
  {https://github.com/tarakojo/ZF_notAC/blob/177e94cf29db6fb3b0be1e4b2f84d5cd7508a7f4/code/HS_Definition.thy\#L32}
  {HS\_Definition.thy}
\begin{minted}[breaklines]{isabelle}
definition sym where "sym(x) ≡ { π ∈ 𝒢. Pn_auto(π)`x = x }"  

definition symmetric where "symmetric(x) ≡ sym(x) ∈ ℱ"  

definition HHS_set_succ where 
  "HHS_set_succ(a, X) ≡ { x ∈ P_set(succ(a)). domain(x) ⊆ X ∧ symmetric(x) }" 

definition HS_set where "HS_set(a) ≡ transrec2(a, 0, HHS_set_succ)"

definition HS where "HS ≡ { x ∈ P_names. ∃a. Ord(a) ∧ x ∈ HS_set(a) }" 
\end{minted}
\end{isaframe2}

The following lemma shows our definition of \texttt{"HS"} is equivalent to \cref{dfn:hereditarily_symmetric}.

\begin{isaframe2}
  {https://github.com/tarakojo/ZF_notAC/blob/177e94cf29db6fb3b0be1e4b2f84d5cd7508a7f4/code/HS_Definition.thy\#L90}
  {HS\_Definition.thy}
\begin{minted}[breaklines]{isabelle}
lemma HS_iff: "x ∈ HS ⟷ x ∈ P_names ∧ domain(x) ⊆ HS ∧ symmetric(x)" 
\end{minted}
\end{isaframe2}


\subsubsection{Symmetric Extensions}
Finally, we define symmetric extensions.

\begin{isaframe2}
  {https://github.com/tarakojo/ZF_notAC/blob/177e94cf29db6fb3b0be1e4b2f84d5cd7508a7f4/code/SymExt_Definition.thy\#L10}
  {SymExt\_Definition.thy}
\begin{minted}[breaklines]{isabelle}
definition SymExt where "SymExt(G) ≡ { val(G, x). x ∈ HS }" 
\end{minted}
\end{isaframe2}

Where \texttt{"val(G, x)"} is the interpretation $x^G$ formalized by \parencite{gunther_forcing}.

We declare a locale \texttt{"M\_symmetric\_system\_G\_generic"},
which combines the locale \texttt{"M\_symmetric\_system"} and the locale \texttt{"G\_generic"}.
\texttt{"G\_generic"} is a locale, defined by \parencite{gunther_forcing}, fixes a generic filter \texttt{"G"} on \texttt{"P"}.

\begin{isaframe2}
  {https://github.com/tarakojo/ZF_notAC/blob/177e94cf29db6fb3b0be1e4b2f84d5cd7508a7f4/code/SymExt_Definition.thy\#L15}
  {SymExt\_Definition.thy}
\begin{minted}[breaklines]{isabelle}
locale M_symmetric_system_G_generic = M_symmetric_system + G_generic
\end{minted}
\end{isaframe2}

The following lemmas can be proved relatively easily in this locale.

\begin{isaframe2}
  {https://github.com/tarakojo/ZF_notAC/blob/177e94cf29db6fb3b0be1e4b2f84d5cd7508a7f4/code/SymExt_Definition.thy\#L18}
  {SymExt\_Definition.thy}
\begin{minted}[breaklines]{isabelle}
lemma M_subset_SymExt : "M ⊆ SymExt(G)" 
lemma SymExt_subset_GenExt : "SymExt(G) ⊆ GenExt(G)" 
lemma Transset_SymExt : "Transset(SymExt(G))" 
lemma SymExt_countable : "nat ≈ SymExt(G)" 
\end{minted}
\end{isaframe2}

Where \texttt{"GenExt(G)"} is the generic extension generated by \texttt{"G"}, 
\texttt{"Transset(A)"} denotes that \texttt{"A"} is transitive, and
\texttt{"nat ≈ A"} denotes that \texttt{"A"} has the same cardinality as the set of natural numbers.


\subsubsection{Formulas Representing These Definitions}
In our proofs, we need to use the separation and replacement axioms in M
based on formulas that include the concepts defined in this section.
Therefore, it is necessary to represent these concepts as internalized formulas.

We utilized the automated formula synethisis method by \parencite{gunther_forcing};
however, it could not applied to complex formulas, 
and re-verifying the properties of the derived formulas in a more usable form remained a repititive task.

Example of the formulas we defined includes \texttt{"is\_P\_auto\_group"}, \texttt{"is\_P\_name\_fm"}, \texttt{"is\_Pn\_auto\_fm"}, and \texttt{"is\_HS\_fm"},
whick represent \texttt{"P\_names"}, \texttt{"Pn\_auto"} and \texttt{"HS"} respectively.
The correctness of these formulas is verified by proving the following lemmas. 

\begin{isaframe2}
  {https://github.com/tarakojo/ZF_notAC/blob/177e94cf29db6fb3b0be1e4b2f84d5cd7508a7f4/code/P_Names_M.thy\#L271}
  {P\_Names\_M.thy}
\begin{minted}[breaklines]{isabelle}
lemma sats_is_P_name_fm_iff : 
    fixes env i j x 
    assumes "env ∈ list(M)" "i < length(env)" "j < length(env)" 
                    "nth(i, env) = P" "nth(j, env) = x"  
    shows "sats(M, is_P_name_fm(i, j), env) ⟷ x ∈ P_names" 

lemma sats_is_Pn_auto_fm_iff :
    fixes x π v env i j k l
    assumes "i < length(env)" "j < length(env)" "k < length(env)" "l < length(env)" 
                    "nth(i, env) = P" "nth(j, env) = π" "nth(k, env) = x" "nth(l, env) = v" 
                    "env ∈ list(M)" "π ∈ P_auto" 
    shows "sats(M, is_Pn_auto_fm(i, j, k, l), env) ⟷ x ∈ P_names ∧ v = Pn_auto(π)`x" 

lemma sats_is_HS_fm_iff : 
    fixes x i j env 
    assumes "env ∈ list(M)" "i < length(env)" "j < length(env)" 
                    "nth(i, env) = <ℱ, 𝒢, P, P_auto>" "nth(j, env) = x" 
    shows "sats(M, is_HS_fm(i, j), env) ⟷ x ∈ HS" 
\end{minted}
\end{isaframe2}

Note that these formulas take as parameters various elements fixed within the locale, 
such as the notion of forcing \texttt{"P"}, the normal filter \texttt{"ℱ"}, etc.


\subsection{Proving Symmetric Extensions are Models of ZF}

In this section, we prove that symmetric extensions are models of ZF.
Initially, we attempted to formalize this based on its proof in \parencite[Theorem 10.10]{karagila},
but we found that additional work was required to formalize parts that are omitted in the note.
Therefore, we decided to prove this by using the relativized forcing relation $\Vdash_{\mathrm{HS}}$.
Initial approach is a traditional method for proving that symmetric extensions are models of ZF,
and applicable to a more general situation since 
it does not rely on forcing or generic and symmetric extensions.
whereas our approach is more specific to the context of symmetric extensions.

\subsubsection{Traditional Approach}

In \parencite[Theorem 10.10]{karagila} and \parencite{jech_set_theory},
the fact that symmetric extensions are models of ZF is proven by showing that 
they are internal models of the conrresponding generic extension
generated by the same notion of forcing and generic filter,
using the following proposition:

\begin{prop}
If $\mathcal{N}$ is a transitive class that is almost universal and satisfies $\Delta_0$-separation, 
then $\mathcal{N}$ is a inner model of ZF.
\end{prop}

Where a class $\mathcal{N}$ is said to be \emph{almost universal} 
\footnote{Jech \parencite{jech_set_theory}, Theorem 13.9.} 
 if every subset $X \subseteq \mathcal{N}$ is included in some $Y \in \mathcal{N}$.
Furthermore, $\mathcal{N}$ is said to satisfy $\Delta_0$-separation if it satisfies the separation axioms for formulas with only bounded quantifiers.

We could prove that the symmetric extension \texttt{"SymExt(G)"} is transitive, almost universal and satisfies $\Delta_0$-separation.
However, 
we found that proving that \texttt{"SymExt(G)"} is actually a class in \texttt{"GenExt(G)"} is not straightforward in Isabelle/ZF.
To do this, we needed to explicitly construct a formula that represents the set of all names \texttt{"P\_names"} on the ground model \texttt{"M"} in \texttt{"GenExt(G)"}.
However, this required additional work, which would likely involve complex discussions.
Therefore, we decided to adopt a different approach.

\subsubsection{Our Approach : The Relativized Forcing Relation $\Vdash_{\mathrm{HS}}$}
Instead, we formalize the relativized forcing relation $\Vdash_{\mathrm{HS}}$ and prove that symmetric extensions are models of ZF using it.
By modifying the formalization of forcing by \parencite{gunther_forcing}, 
we were able to define this relation and prove its properties relatively easily.

Within the locale \texttt{"M\_symmetric\_system"},
we define this relation in the form \texttt{"p ⊩HS φ env"},
which has the same form as the formalization of the original forcing relation \texttt{"p ⊩ φ env"} by Gunther et al.
Our definition satisfies the required properties, such as \cref{thm:symmetry_truth_lemma}, \cref{cor:symmetry_truth_lemma_cor}, and \cref{lem:strengthening}.

\begin{isaframe2}
  {https://github.com/tarakojo/ZF_notAC/blob/177e94cf29db6fb3b0be1e4b2f84d5cd7508a7f4/code/HS_Forces.thy\#L1027}
  {HS\_Forces.thy}
\begin{minted}[breaklines]{isabelle}
lemma HS_truth_lemma:
    assumes 
        "φ∈formula" "M_generic(G)"
    shows 
        "⋀env. env∈list(HS) ⟹ arity(φ)≤length(env) ⟹ 
              (∃p∈G. p ⊩HS φ env) ⟷ SymExt(G), map(val(G),env) ⊨ φ"

lemma definition_of_forcing_HS:
    assumes
        "p∈P" "φ∈formula" "env∈list(HS)" "arity(φ)≤length(env)"
    shows
        "(p ⊩HS φ env) ⟷
              (∀G. M_generic(G) ∧ p∈G  ⟶  SymExt(G), map(val(G),env) ⊨ φ)"

lemma HS_strengthening_lemma:
    assumes 
        "p∈P" "φ∈formula" "r∈P" "r≼p"
    shows
        "⋀env. env∈list(M) ⟹ arity(φ)≤length(env) ⟹ p ⊩HS φ env ⟹ r ⊩HS φ env"
\end{minted}
\end{isaframe2}


\subsubsection{The Symmetry Lemma}
Additionally, we prove the symmetry lemma (\cref{lem:symmetry_lemma}).
Similary to the definitions of the forcing relations, this lemma is proven using a complex induction.
First, we prove this lemma for atomic formulas in the forcing language, 
and then extend the proof to other formulas by structual induction on the formula.
For atomic formulas $\dot{x} = \dot{y}$ and $\dot{x} \in \dot{y}$, 
the definition is mutually recursive, so the lemma for these formulas is proven simultaneously
by induction on the $\mathbb{P}$-rank of $\dot{x}$ and $\dot{y}$.
Specifically, we show these induction steps:

\begin{isaframe2}
  {https://github.com/tarakojo/ZF_notAC/blob/177e94cf29db6fb3b0be1e4b2f84d5cd7508a7f4/code/Symmetry_Lemma.thy\#L22}
  {Symmetry\_Lemma.thy}
\begin{minted}[breaklines]{isabelle}
  have MEM_step: "⋀a. Ord(a) ⟹ ∀b ∈ a. Q(EQ, b, b) ⟹ ∀b ∈ a. Q(MEM, b, a)"  
  have EQ_step : "⋀a. Ord(a) ⟹ ∀b ∈ a. Q(MEM, b, a) ⟹ Q(EQ, a, a)"   
\end{minted}
\end{isaframe2}

Where \texttt{"Q(MEM, α, β)"} and \texttt{"Q(EQ, α, β)"} are predicates 
representing that the symmetriy lemma holds for $\dot{x} \in \dot{y}$ and $\dot{x} = \dot{y}$, respectively,
for any $\dot{x}$ with $\mathbb{P}$-rank at most $\alpha$ and $\dot{y}$ with $\mathbb{P}$-rank at most $\beta$.

The proof for non-atomic formulas is relatively straightforward, and finally, 
this completes the proof of the lemma.

\begin{isaframe2}
  {https://github.com/tarakojo/ZF_notAC/blob/177e94cf29db6fb3b0be1e4b2f84d5cd7508a7f4/code/Symmetry_Lemma.thy\#L596}
  {Symmetry\_Lemma.thy}
\begin{minted}[breaklines]{isabelle}
lemma symmetry_lemma:
    fixes φ π  
    assumes "φ ∈ formula" "is_P_auto(π)" "π ∈ 𝒢" 
    shows "⋀env p. env ∈ list(HS) ⟹ arity(φ) ≤ length(env) ⟹ p ∈ P ⟹ 
                p ⊩HS φ env ⟷ π`p ⊩HS φ map(λx. Pn_auto(π)`x, env)" 
\end{minted}
\end{isaframe2}


\subsubsection{Separation}
Using the symmetry lemma, we prove the axiom schema of separation for symmetric extensions 
within the locale \texttt{"M\_symmetric\_system\_G\_generic"}.
Our proof is based on Karagila's proof \parencite{karagila} of $\Delta_0$-separation for symmetric extensions.
However, since we use the $\Vdash_{\mathrm{HS}}$ relation instead of $\Vdash$,
we can prove separation for any formula, not just $\Delta_0$ formulas.

The separation for the formula $\varphi$ means that 
for any elements $x, p$ in the symmetric extension, the set $X = \{ y \in x \mid \varphi(y, p) \}$ is also an element of it.
To prove this, we show that 
$\dot{X} = \{ \langle y, p \rangle \in \mathrm{dom}(x) \times \mathbb{P} \mid p \Vdash_{\mathrm{HS}} \varphi(\dot{y}, \dot{p}) \}$ is a hereditarily symmetric name of $X$,
i.e., $\dot{X} \in \mathrm{HS}$ and $\dot{X}^G = X$.

\begin{isaframe2}
  {https://github.com/tarakojo/ZF_notAC/blob/177e94cf29db6fb3b0be1e4b2f84d5cd7508a7f4/code/SymExt_Separation.thy\#L133}
  {SymExt\_Separation.thy}
\begin{minted}[breaklines]{isabelle}
lemma sep_forces_pair_in_HS : 
    fixes x env φ
    assumes "x ∈ HS" "env ∈ list(HS)" "φ ∈ formula" "arity(φ) ≤ succ(length(env))" 
    shows "{ <y, p> ∈ domain(x) × P. p ⊩HS φ [y] @ env } ∈ HS"

lemma SymExt_separation : 
    fixes x env φ 
    assumes "x ∈ SymExt(G)" "env ∈ list(SymExt(G))" 
                    "φ ∈ formula" "arity(φ) ≤ succ(length(env))" 
    shows "{ y ∈ x. sats(SymExt(G), φ, [y] @ env) } ∈ SymExt(G)"
\end{minted}
\end{isaframe2}


\subsubsection{Replacement}
Now that we have proven separation, to prove the axiom schema of replacement for symmetric extensions,
it is sufficient to show that for any formula $\varphi$ and any elements $x, p$ in a symmetric extension $\mathcal{N}$,
we can find a set $S \in \mathcal{N}$ such that : 
$$\mathcal{N} \vDash \exists z \, \varphi(y, z, p) \text{ iff }
  \mathcal{N} \vDash \exists z \, (z \in S \land \varphi(y, z, p)) \text{ for all } y \in x$$
This is because such a set $S$ contains the image of $x$ under the class function defined by $\varphi$ 
\footnote{If $\varphi$ defines a class function.},
which is the set that would be obtained by applying the replacement axiom.
To prove this, we show the following lemma, which rewrites the above statement in terms of the forcing relation $\Vdash_{\mathrm{HS}}$,
and then prove it.
\begin{isaframe2}
  {https://github.com/tarakojo/ZF_notAC/blob/177e94cf29db6fb3b0be1e4b2f84d5cd7508a7f4/code/SymExt_Replacement.thy\#L366}
  {SymExt\_Replacement.thy}
\begin{minted}[breaklines]{isabelle}
lemma ex_hs_subset_contains_witnesses : 
    fixes φ env x 
    assumes "φ ∈ formula" "env ∈ list(M)" "arity(φ) ≤ 2 #+ length(env)" "x ∈ M" 
    shows "∃S. S ∈ M ∧ S ⊆ HS ∧ (∀p ∈ G. ∀y ∈ domain(x). 
                (∃z ∈ HS. p ⊩HS φ ([y, z] @ env)) ⟷ (∃z ∈ S. p ⊩HS φ ([y, z] @ env)))" 

  lemma ex_SymExt_elem_contains_witnesses : 
    fixes φ env x 
    assumes "φ ∈ formula" "env ∈ list(SymExt(G))" 
                "arity(φ) ≤ 2 #+ length(env)" "x ∈ SymExt(G)" 
    shows "∃S ∈ SymExt(G). ∀y ∈ x. 
                ((∃z ∈ SymExt(G). sats(SymExt(G), φ, [y, z] @ env)) 
                ⟷ (∃z ∈ S. sats(SymExt(G), φ, [y, z] @ env)))"
\end{minted}
\end{isaframe2}

Additionally, the following lemma was helpful in these proofs.
This is also frequently used in the proofs of the axioms.

\begin{isaframe2}
  {https://github.com/tarakojo/ZF_notAC/blob/177e94cf29db6fb3b0be1e4b2f84d5cd7508a7f4/code/SymExt_Separation_Base.thy\#L524}
  {SymExt\_Separation\_Base.thy}
\begin{minted}[breaklines]{isabelle}
lemma ex_separation_base : 
    fixes X 
    assumes "X ⊆ HS" "X ∈ M" 
    shows "∃S ∈ SymExt(G). { val(G, x). x ∈ X } ⊆ S" 
\end{minted}
\end{isaframe2}
This lemma states that for any set of hereditarily symmetric names $X \in M$, 
there exists a set $S$ in the symmetric extension such that $X^G \subseteq S$.

Then, we prove the axiom schema of replacement for symmetric extensions.
\begin{isaframe2}
  {https://github.com/tarakojo/ZF_notAC/blob/177e94cf29db6fb3b0be1e4b2f84d5cd7508a7f4/code/SymExt_Replacement.thy\#L534}
  {SymExt\_Replacement.thy}
\begin{minted}[breaklines]{isabelle}
lemma SymExt_replacement :
    fixes φ env
    assumes "φ ∈ formula" "arity(φ) ≤ 2 #+ length(env)" "env ∈ list(SymExt(G))" 
    shows 
          "strong_replacement(##SymExt(G), λx y. sats(SymExt(G), φ, [x, y] @ env))" 
\end{minted}
\end{isaframe2}


\subsubsection{Other Axioms}
Other axioms of ZF can be proven relatively easily in symmetric extensions by using separation, replacement and the lemma \texttt{"ex\_separation\_base"}.
For example, the axiom of pairing can be proven as follows. 
Let a, b be elements of a symmetric extension $\mathcal{N}$.
Then, we can take hereditarily symmetric names $\dot{a}, \dot{b}$ of a, b, respectively.
By the lemma \texttt{"ex\_separation\_base"}, we can find a set $S$ in $\mathcal{N}$ such that $\{ \dot{a}, \dot{b} \}^G \subseteq S$.
In other words, $\{ a, b \} \subseteq S$. 
Then by the separation axiom, $\{ x \in S \mid x = a \lor x = b \} = \{ a, b \}$ is an element of $\mathcal{N}$.

Finally we obtain the following lemma, which states that symmetric extensions are models of ZF.
\begin{isaframe2}
  {https://github.com/tarakojo/ZF_notAC/blob/177e94cf29db6fb3b0be1e4b2f84d5cd7508a7f4/code/SymExt_ZF.thy\#L372}
  {SymExt\_ZF.thy}
\begin{minted}[breaklines]{isabelle}
theorem SymExt_sats_ZF : "SymExt(G) ⊨ ZF" 
\end{minted}
\end{isaframe2}

Furthermore, since symmetric extensions are transitive, it can be shown that they are 
instances of the locale \texttt{"M\_ZF\_trans"}.
As a result, many results concerning ZF set theory formalized in this locale can now be applied to symmetric extensions.

\begin{isaframe2}
  {https://github.com/tarakojo/ZF_notAC/blob/177e94cf29db6fb3b0be1e4b2f84d5cd7508a7f4/code/SymExt_ZF.thy\#L372}
  {SymExt\_ZF.thy}
\begin{minted}[breaklines]{isabelle}
lemma SymExt_M_ZF_trans : "M_ZF_trans(SymExt(G))"
\end{minted}
\end{isaframe2}



\section{The Basic Cohen Model}


\subsection{Defining the Basic Cohen Model}
In this section, we define the basic Cohen model which is a symmetric extension that does not satisfy the Axiom of Choice,
, as outlined in \cref{sec:outline}.
First, we work within the locale \texttt{"M\_ctm"} which fixes a c.t.m.\  \texttt{"M"} of ZF.


\subsubsection{The Notion of Forcing}
the notion of forcing for the basic Cohen model is defined as the set of finite partial functions from $\omega \times \omega$ to $2$ that are elements of the ground model,
with the order relation given by the superset relation.
We define these as \texttt{"Fn"} and \texttt{"Fn\_leq"} in Isabelle/ZF.

\begin{isaframe2}
  {https://github.com/tarakojo/ZF_notAC/blob/177e94cf29db6fb3b0be1e4b2f84d5cd7508a7f4/code/Fn_Perm_Definition.thy\#L139}
  {Fn\_Perm\_Definition.thy}
\begin{minted}[breaklines]{isabelle}
definition Fn where "Fn ≡ { f ∈ Pow((nat × nat) × 2) ∩ M. 
                function(f) ∧ domain(f) ⊆ nat × nat ∧ finite_M(domain(f)) ∧ range(f) ⊆ 2 }"

definition Fn_leq where "Fn_leq ≡ { <f, g> ∈ Fn × Fn. g ⊆ f }" 
\end{minted}
\end{isaframe2}
Where \texttt{"nat"} denotes $\omega$ and \texttt{"finite\_M(A)"} denotes that the set \texttt{"A"} is finite.
From the following lemma, this ordered set is an instance of the locale \texttt{"forcing\_data\_partial"}, 
meaning that this is indeed a notion of forcing and forms a partially ordered set with the empty set as the maximum element.
\begin{isaframe2}
  {https://github.com/tarakojo/ZF_notAC/blob/177e94cf29db6fb3b0be1e4b2f84d5cd7508a7f4/code/Fn_Perm_Definition.thy\#L215}
  {Fn\_Perm\_Definition.thy}
\begin{minted}[breaklines]{isabelle}
lemma Fn_forcing_data_partial : "forcing_data_partial(Fn, Fn_leq, 0, M, enum)" 
\end{minted}
\end{isaframe2}
Where \texttt{"enum"} is the enumeration function of the set \texttt{"M"} fixed in the locale \texttt{"M\_ctm"}.


\subsubsection{The Group of Automorphisms and the Normal Filter}
Next, we define the group of automorphisms \texttt{"Fn\_perms"} on the forcing notion \texttt{"Fn"}.
\begin{isaframe2}
  {https://github.com/tarakojo/ZF_notAC/blob/177e94cf29db6fb3b0be1e4b2f84d5cd7508a7f4/code/Fn_Perm_Definition.thy\#L220}
  {Fn\_Perm\_Definition.thy}
\begin{minted}[breaklines]{isabelle}
definition nat_perms where "nat_perms ≡ bij(nat, nat) ∩ M" 
definition Fn_perm where "Fn_perm(f, p) ≡ { <<f`n, m>, l> . <<n, m>, l> ∈ p }" 
definition Fn_perm' where "Fn_perm'(f) ≡ { <p, Fn_perm(f, p)>. p ∈ Fn }" 
definition Fn_perms where "Fn_perms ≡ { Fn_perm'(f). f ∈ nat_perms }" 
\end{minted}
\end{isaframe2}
Note that \texttt{"Fn\_perm'(f)"} is the automorphism induced by the bijection \texttt{"f"} on $\omega$,
and \texttt{"Fn\_perm(f, p)"} is the value of the automorphism \texttt{"Fn\_perm'(f)"} on the partial function \texttt{"p"}.
We prove that \texttt{"Fn\_perm'(f)"} is indeed an automorphism on \texttt{"Fn"} and 
\texttt{"Fn\_perms"} is a group of automorphisms on \texttt{"Fn"},
i.e., closed under composition and the inverse operation, and contains the identity function.

\begin{isaframe2}
  {https://github.com/tarakojo/ZF_notAC/blob/177e94cf29db6fb3b0be1e4b2f84d5cd7508a7f4/code/Fn_Perm_Automorphism.thy\#L634}
  {Fn\_Perm\_Automorphism.thy}
\begin{minted}[breaklines]{isabelle}
lemma Fn_perm'_is_P_auto : 
    fixes f 
    assumes "f ∈ nat_perms" 
    shows "forcing_data_partial.is_P_auto(Fn, Fn_leq, M, Fn_perm'(f))"

lemma Fn_perms_group : 
    "forcing_data_partial.is_P_auto_group(Fn, Fn_leq, M, Fn_perms)" 
\end{minted}
\end{isaframe2}

Then, we define the normal filter \texttt{"Fn\_perms\_filter"} on the group of automorphisms \texttt{"Fn\_perms"},
and verify that our definition satisfies the prerequisites of the locale \texttt{"M\_symmetric\_system"}.
This completes both the definition of the basic Cohen model and
the proof that it is a model of ZF.

\begin{isaframe2}
  {https://github.com/tarakojo/ZF_notAC/blob/177e94cf29db6fb3b0be1e4b2f84d5cd7508a7f4/code/Fn_Perm_Filter.thy\#L316}
  {Fn\_Perm\_Filter.thy}
\begin{minted}[breaklines]{isabelle}
definition Fn_perms_filter where "Fn_perms_filter ≡ { 
              H ∈ forcing_data_partial.P_auto_subgroups(Fn, Fn_leq, M, Fn_perms).  
              ∃E ∈ Pow(nat) ∩ M. finite_M(E) ∧ Fix(E) ⊆ H }" 

lemma Fn_M_symmetric_system : 
    "M_symmetric_system(Fn, Fn_leq, 0, M, enum, Fn_perms, Fn_perms_filter)" 
\end{minted}
\end{isaframe2}


\subsection{Proving the Basic Cohen Model does not Satisfy AC}
Finaly, we prove that the basic Cohen model does not satisfy the Axiom of Choice.
To do this, we construct a set $A$ that cannot be well-ordered in it.
We work within the locale \texttt{"M\_symmetric\_system"} with parameters, as defined above, 
fixed to generate the basic Cohen model.

We formalize $a_n$ and $A$, introduced in \cref{sec:outline}, 
as \texttt{"binmap\_row(G, n)"} and \texttt{"binmap(G)"}, respectively, for given generic filter \texttt{"G"}.
\begin{isaframe2}
  {https://github.com/tarakojo/ZF_notAC/blob/177e94cf29db6fb3b0be1e4b2f84d5cd7508a7f4/code/NotAC_Binmap.thy\#L11}
  {NotAC\_Binmap.thy}
\begin{minted}[breaklines]{isabelle}
definition binmap_row where 
    "binmap_row(G, n) ≡ { m ∈ nat. ∃p ∈ G. p`<n, m> = 1 }"

definition binmap where "binmap(G) ≡ { binmap_row(G, n). n ∈ nat }" 
\end{minted}
\end{isaframe2}
Then, we prove that $a_n$ are pairwise disjoint, which implies that $A$ is an infinite set.
\begin{isaframe2}
  {https://github.com/tarakojo/ZF_notAC/blob/177e94cf29db6fb3b0be1e4b2f84d5cd7508a7f4/code/NotAC_Binmap.thy\#L1120}
  {NotAC\_Binmap.thy}
\begin{minted}[breaklines]{isabelle}
lemma binmap_row_distinct : 
    fixes G n m 
    assumes "M_generic(G)" "n ∈ nat" "m ∈ nat" "n ≠ m" 
    shows "binmap_row(G, n) ≠ binmap_row(G, m)" 
\end{minted}
\end{isaframe2}
Using this lemma, we prove that 
$p \Vdash_{\mathrm{HS}} \text{"} \dot{F} \text{ is a injection from } \dot{\omega} \text{ to } \dot{A} \text{"}$ leads a contradiction 
for any $p \in $ \texttt{"Fn"} and $\dot{F} \in $ \texttt{"HS"}.
This means that there is no injection from $\omega$ to $A$ in the basic Cohen model.
\begin{isaframe2}
  {https://github.com/tarakojo/ZF_notAC/blob/177e94cf29db6fb3b0be1e4b2f84d5cd7508a7f4/code/NotAC_Proof.thy\#L14}
  {NotAC\_Proof.thy}
\begin{minted}[breaklines]{isabelle}
lemma no_injection : 
  fixes F' p0
  assumes "F' ∈ HS" "p0 ∈ Fn"  
                  "ForcesHS(p0, injection_fm(0, 1, 2), [check(nat), binmap', F'])" 
  shows False
\end{minted}
\end{isaframe2}
Where \texttt{"ForcesHS(p, φ, env)"} is another notation for \texttt{"p ⊩HS φ env"},
and \texttt{"check(nat)"} and \texttt{"binmap'"} are the hereditarily symmetric names of \texttt{"nat"} and \texttt{"binmap"}, respectively.

Since $A$ is an infinite set, there exists an injection from $\omega$ to $A$.
Therefore, using above lemma, we can show that assuming $A$ is well-orderable leads to a contradiction,

\begin{isaframe2}
  {https://github.com/tarakojo/ZF_notAC/blob/177e94cf29db6fb3b0be1e4b2f84d5cd7508a7f4/code/NotAC_Proof.thy\#L631}
  {NotAC\_Proof.thy}
\begin{minted}[breaklines]{isabelle}
lemma no_wellorder : 
    fixes r G
    assumes 
            "M_generic(G)" "wellordered(##SymExt(G), binmap(G), r)" "r ∈ SymExt(G)" 
    shows False
\end{minted}
\end{isaframe2}

Where \texttt{"wellordered(C, A, r)"} denotes that 
the relation \texttt{"r"} is a well-ordering of the set \texttt{"A"} in the class \texttt{"C"}, 
and \texttt{"\#\#"} is an operator that converts a set to a class.
These are defined by \parencite{paulson_AC_consistency}.
Specifically, the definition of \texttt{"wellordered"} is as follows
\footnote{
Note that we can show that 
if \texttt{"wellordered(N, A, r)"} holds for an element \texttt{"A"} in a class \texttt{"N"}, which is a model of ZF,
then \texttt{"r"} is irreflexive and assymetric, i.e., a strict total order.
}:
\begin{isaframe}
\begin{minted}[breaklines]{isabelle}
definition transitive_rel :: "[i⇒o,i,i]⇒o" where
    "transitive_rel(M,A,r) ≡ 
        ∀x[M]. x∈A ⟶ (∀y[M]. y∈A ⟶ (∀z[M]. z∈A ⟶ 
                          ⟨x,y⟩∈r ⟶ ⟨y,z⟩∈r ⟶ ⟨x,z⟩∈r))"
definition linear_rel :: "[i⇒o,i,i]⇒o" where
    "linear_rel(M,A,r) ≡ 
        ∀x[M]. x∈A ⟶ (∀y[M]. y∈A ⟶ ⟨x,y⟩∈r | x=y | ⟨y,x⟩∈r)"

definition wellfounded_on :: "[i⇒o,i,i]⇒o" where
    ― ‹every non-empty SUBSET OF ‹A› has an ‹r›-minimal element›
    "wellfounded_on(M,A,r) ≡ 
        ∀x[M]. x≠0 ⟶ x⊆A ⟶ (∃y[M]. y∈x ∧ ¬(∃z[M]. z∈x ∧ ⟨z,y⟩ ∈ r))"
        
definition wellordered :: "[i⇒o,i,i]⇒o" where
    ― ‹linear and wellfounded on ‹A››
    "wellordered(M,A,r) ≡ 
        transitive_rel(M,A,r) ∧ linear_rel(M,A,r) ∧ wellfounded_on(M,A,r)"
\end{minted}
\end{isaframe}

Thus, the statement "a set $\mathcal{N}$ satisfies well-ordering theorem" can be written as follows:
\begin{isaframe}
\begin{minted}[breaklines]{isabelle}
"∀A ∈ N. ∃r ∈ N. wellordered(##N, A, r)"
\end{minted}
\end{isaframe}

Using the above, we prove the following theorem and complete our relative consistency proof.
This theorem has no additional assumptions from any locale.
\begin{isaframe2}
  {https://github.com/tarakojo/ZF_notAC/blob/177e94cf29db6fb3b0be1e4b2f84d5cd7508a7f4/code/ZF_notAC.thy\#L6}
  {ZF\_notAC.thy}
\begin{minted}[breaklines]{isabelle}
theorem ZF_notAC_main_theorem :
    fixes M 
    assumes "nat ≈ M" "M ⊨ ZF" "Transset(M)" 
    shows "∃N. nat ≈ N ∧ N ⊨ ZF ∧ Transset(N) 
                ∧ ¬(∀A ∈ N. ∃r ∈ N. wellordered(##N, A, r))" 
\end{minted}
\end{isaframe2}
This theorem states that there exists a c.t.m.\ \texttt{"N"} of ZF+$\neg$AC if there exists a c.t.m.\ \texttt{"M"} of ZF.




\chapter{Conclusion} \label{chap:conclusion}

\paragraph{Summary of Our Results}
We formalized the relative consistency proof of $\neg$AC with ZF
on the basis of the work by \parencite{paulson_AC_consistency} and \parencite{gunther_forcing}.
Specifically, assuming the existence of a c.t.m.\ of ZF, 
we constructed a model of ZF+$\neg$AC known as the Basic Cohen model by forcing. 
To achieve this, we formalized the definition of symmetric extensions and the related lemmas.

Our formalization comprises approximately 15,000 lines of code, 
distributed roughly as follows:
\begin{itemize}
  \item Definition of symmetric extensions: 3,000 lines
  \item Proof of symmetric extensions are models of ZF: 5,000 lines
  \item Definition of the basic Cohen model: 2,000 lines
  \item Proof of the basic Cohen model does not satisfy AC: 2,000 lines
  \item Other lemmas : 3,000 lines
\end{itemize}
This is as large as Paluson's formalization of the proof of relative consistency of AC (12,000 lines), 
Gunther et al.'s formalization of coercion (16,000 lines), 
and their proof of independence of CH (12,000 lines).

\paragraph{Discussion and Future Work}
Through the formalization, we felt particularly deficient of 
functionality to efficiently formalize “object-level” arguments in axiomatic set theory.

In our proof, we needed to construct internalized formulas 
representing most of the concepts that belong to the ground model. 
This was to verify that the defined sets truly belong to the ground model 
and to enable application of the separation and replacement axioms of the ground model for formulas that include these concepts.

For constructing these formulas we utilized the sythesis method by \parencite{gunther_forcing};
however, this method could not be applied to complex formulas.
When applied, we also needed to reprove properties of derived formulas in a more usable form.

We also needed to prove that the arity of each defined formula is below its respective threshold.
For complex formulas, Isabelle's automated proof tools were not applicable, 
and we had to prove these properties manually.

Since these works are repetitive, further automation is desirable.
Ideally, if the arguments of the base model could be handled without explicitly dealing with internalized formulas, 
the amount of work could be reduced when formalizing proofs by using an approach similar to ours.

Additionally, we used the c.t.m.\ approach, and the formalized argument only extends to the construction of a model of ZF+$\neg$AC,
assuming the existence of a c.t.m.\ of ZF.
We did not formalize the justification of the c.t.m.\ approach itself.
However, it is also desirable to formalize this part.

The main obstacle to formalizing this part lies in the reflection principle. 
The reflection principle for propositions of Isabelle 
was proved by \parencite{paulson_reflection}; 
however, since we are dealing with propositions formalized in the form of internalized formulas, 
we need a reflection principle for such formulas.

There are several approaches to address this. 
One approach is to use metaprogramming, 
which involves writing a program to automatically generate proofs 
for specific instances of the reflection principle. 
In this case, only a finite number of instances of the reflection principle can be utilized, 
and the finite set of logical formulas as parameters for each instance must be explicitly constructed. 
This means that the reflection principle cannot be applied to finite sets of logical formulas obtained non-constructively.

Another approach is to prove a general reflection principle for internalized formulas. 
This would require discussing "object-level within object-level", that is, 
a further layer of encoded set theory within models of ZF or ZFC. Since even "object-level" arguments, 
such as those handled in this formalization, are already sufficiently complex, 
this approach would be difficult unless the aforementioned automation is achieved.

The final approach is to use higher-order logic. 
In higher-order logic, it would be possible to prove the reflection principle for internalized formulas 
without engaging in the complex discussions of "object-level within object-level". 
However, this would require using a proof assistant other than Isabelle/ZF. 
Since the accumulated definitions and lemmas in Isabelle/ZF would not be available, 
it would be necessary to re-formalize set-theoretic concepts such as forcing.

The automation of "object-level" arguments and the formalization of the validity of the c.t.m.\ approach mentioned above are interesting future work. 
Additionally, it would be interesting to formalize more advanced topics on symmetric extensions, 
as seen in the latter parts of \parencite{karagila}. 
Furthermore, formalizing the fact that the consistency of an axiomatic system $S$ does not imply the existence of a c.t.m.\ of $S$, 
as well as alternative approaches to forcing, 
such as those using modal logic, 
and formalizing the connections between different approaches to forcing, 
are also intriguing topics for future exploration.
\printbibliography
\end{document}
 